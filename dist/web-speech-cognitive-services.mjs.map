{"version":3,"sources":["../src/SpeechServices/SpeechToText/createSpeechRecognitionPonyfill.js","../src/Util/arrayToMap.js","../src/SpeechServices/SpeechSDK.js","../src/SpeechServices/SpeechToText/cognitiveServiceEventResultToWebSpeechRecognitionResultList.js","../../../node_modules/p-defer/index.js","../src/Util/createPromiseQueue.js","../src/SpeechServices/resolveFunctionOrReturnValue.ts","../src/SpeechServices/patchOptions.js","../src/SpeechServices/SpeechToText/SpeechGrammarList.js","../src/SpeechServices/SpeechToText.js","../src/SpeechServices/TextToSpeech/createSpeechSynthesisPonyfill.js","../src/SpeechServices/TextToSpeech/AudioContextQueue.js","../src/SpeechServices/TextToSpeech/AudioContextConsumer.js","../src/SpeechServices/TextToSpeech/SpeechSynthesisEvent.js","../src/SpeechServices/TextToSpeech/SpeechSynthesisUtterance.js","../src/SpeechServices/TextToSpeech/fetchSpeechData.js","../src/SpeechServices/TextToSpeech/buildSSML.js","../src/SpeechServices/TextToSpeech/isSSML.js","../src/SpeechServices/TextToSpeech/subscribeEvent.js","../src/SpeechServices/TextToSpeech/SpeechSynthesisVoice.js","../src/SpeechServices/TextToSpeech/fetchCustomVoices.js","../src/SpeechServices/TextToSpeech/fetchVoices.js","../src/SpeechServices/TextToSpeech.js","../src/SpeechServices/fetchAuthorizationToken.js","../src/SpeechServices.js"],"sourcesContent":["/* eslint class-methods-use-this: \"off\" */\r\n/* eslint complexity: [\"error\", 70] */\r\n/* eslint no-await-in-loop: \"off\" */\r\n/* eslint no-empty-function: \"off\" */\r\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100, 150] }] */\r\n\r\nimport { Event, EventTarget, getEventAttributeValue, setEventAttributeValue } from 'event-target-shim';\r\n\r\nimport cognitiveServiceEventResultToWebSpeechRecognitionResultList from './cognitiveServiceEventResultToWebSpeechRecognitionResultList';\r\nimport createPromiseQueue from '../../Util/createPromiseQueue';\r\nimport patchOptions from '../patchOptions';\r\nimport SpeechGrammarList from './SpeechGrammarList';\r\nimport SpeechSDK from '../SpeechSDK';\r\n\r\n// https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat\r\n// {\r\n//   \"RecognitionStatus\": \"Success\",\r\n//   \"Offset\": 900000,\r\n//   \"Duration\": 49000000,\r\n//   \"NBest\": [\r\n//     {\r\n//       \"Confidence\": 0.738919,\r\n//       \"Lexical\": \"second\",\r\n//       \"ITN\": \"second\",\r\n//       \"MaskedITN\": \"second\",\r\n//       \"Display\": \"Second.\"\r\n//     }\r\n//   ]\r\n// }\r\n\r\n// {\r\n//   \"RecognitionStatus\": \"InitialSilenceTimeout\",\r\n//   \"Offset\": 50000000,\r\n//   \"Duration\": 0\r\n// }\r\n\r\nconst { AudioConfig, OutputFormat, ResultReason, SpeechConfig, SpeechRecognizer } = SpeechSDK;\r\n\r\nfunction serializeRecognitionResult({ duration, errorDetails, json, offset, properties, reason, resultId, text }) {\r\n  return {\r\n    duration,\r\n    errorDetails,\r\n    json: JSON.parse(json),\r\n    offset,\r\n    properties,\r\n    reason,\r\n    resultId,\r\n    text\r\n  };\r\n}\r\n\r\nfunction averageAmplitude(arrayBuffer) {\r\n  const array = new Int16Array(arrayBuffer);\r\n\r\n  return (\r\n    [].reduce.call(array, (averageAmplitude, amplitude) => averageAmplitude + Math.abs(amplitude), 0) / array.length\r\n  );\r\n}\r\n\r\nfunction cognitiveServicesAsyncToPromise(fn) {\r\n  return (...args) => new Promise((resolve, reject) => fn(...args, resolve, reject));\r\n}\r\n\r\nclass SpeechRecognitionEvent extends Event {\r\n  constructor(type, { data, emma, interpretation, resultIndex, results } = {}) {\r\n    super(type);\r\n\r\n    this.data = data;\r\n    this.emma = emma;\r\n    this.interpretation = interpretation;\r\n    this.resultIndex = resultIndex;\r\n    this.results = results;\r\n  }\r\n}\r\n\r\nfunction prepareAudioConfig(audioConfig) {\r\n  const originalAttach = audioConfig.attach;\r\n  const boundOriginalAttach = audioConfig.attach.bind(audioConfig);\r\n  let firstChunk;\r\n  let muted;\r\n\r\n  // We modify \"attach\" function and detect when audible chunk is read.\r\n  // We will only modify \"attach\" function once.\r\n  audioConfig.attach = async () => {\r\n    const reader = await boundOriginalAttach();\r\n\r\n    return {\r\n      ...reader,\r\n      read: async () => {\r\n        const chunk = await reader.read();\r\n\r\n        // The magic number 150 is measured by:\r\n        // 1. Set microphone volume to 0\r\n        // 2. Observe the amplitude (100-110) for the first few chunks\r\n        //    (There is a short static caught when turning on the microphone)\r\n        // 3. Set the number a bit higher than the observation\r\n\r\n        if (!firstChunk && averageAmplitude(chunk.buffer) > 150) {\r\n          audioConfig.events.onEvent({ name: 'FirstAudibleChunk' });\r\n          firstChunk = true;\r\n        }\r\n\r\n        if (muted) {\r\n          return { buffer: new ArrayBuffer(0), isEnd: true, timeReceived: Date.now() };\r\n        }\r\n\r\n        return chunk;\r\n      }\r\n    };\r\n  };\r\n\r\n  return {\r\n    audioConfig,\r\n    pause: () => {\r\n      muted = true;\r\n    },\r\n    unprepare: () => {\r\n      audioConfig.attach = originalAttach;\r\n    }\r\n  };\r\n}\r\n\r\nexport function createSpeechRecognitionPonyfillFromRecognizer({\r\n  createRecognizer,\r\n  enableTelemetry,\r\n  looseEvents,\r\n  referenceGrammars,\r\n  textNormalization\r\n}) {\r\n  // If enableTelemetry is set to null or non-boolean, we will default to true.\r\n  SpeechRecognizer.enableTelemetry(enableTelemetry !== false);\r\n\r\n  class SpeechRecognition extends EventTarget {\r\n    constructor() {\r\n      super();\r\n\r\n      this._continuous = false;\r\n      this._interimResults = false;\r\n      this._lang =\r\n        typeof window !== 'undefined'\r\n          ? window.document.documentElement.getAttribute('lang') || window.navigator.language\r\n          : 'en-US';\r\n      this._grammars = new SpeechGrammarList();\r\n      this._maxAlternatives = 1;\r\n    }\r\n\r\n    emitCognitiveServices(type, event) {\r\n      this.dispatchEvent(\r\n        new SpeechRecognitionEvent('cognitiveservices', {\r\n          data: {\r\n            ...event,\r\n            type\r\n          }\r\n        })\r\n      );\r\n    }\r\n\r\n    get continuous() {\r\n      return this._continuous;\r\n    }\r\n\r\n    set continuous(value) {\r\n      this._continuous = value;\r\n    }\r\n\r\n    get grammars() {\r\n      return this._grammars;\r\n    }\r\n\r\n    set grammars(value) {\r\n      if (value instanceof SpeechGrammarList) {\r\n        this._grammars = value;\r\n      } else {\r\n        throw new Error(`The provided value is not of type 'SpeechGrammarList'`);\r\n      }\r\n    }\r\n\r\n    get interimResults() {\r\n      return this._interimResults;\r\n    }\r\n\r\n    set interimResults(value) {\r\n      this._interimResults = value;\r\n    }\r\n\r\n    get maxAlternatives() {\r\n      return this._maxAlternatives;\r\n    }\r\n\r\n    set maxAlternatives(value) {\r\n      this._maxAlternatives = value;\r\n    }\r\n\r\n    get lang() {\r\n      return this._lang;\r\n    }\r\n\r\n    set lang(value) {\r\n      this._lang = value;\r\n    }\r\n\r\n    get onaudioend() {\r\n      return getEventAttributeValue(this, 'audioend');\r\n    }\r\n\r\n    set onaudioend(value) {\r\n      setEventAttributeValue(this, 'audioend', value);\r\n    }\r\n\r\n    get onaudiostart() {\r\n      return getEventAttributeValue(this, 'audiostart');\r\n    }\r\n\r\n    set onaudiostart(value) {\r\n      setEventAttributeValue(this, 'audiostart', value);\r\n    }\r\n\r\n    get oncognitiveservices() {\r\n      return getEventAttributeValue(this, 'cognitiveservices');\r\n    }\r\n\r\n    set oncognitiveservices(value) {\r\n      setEventAttributeValue(this, 'cognitiveservices', value);\r\n    }\r\n\r\n    get onend() {\r\n      return getEventAttributeValue(this, 'end');\r\n    }\r\n\r\n    set onend(value) {\r\n      setEventAttributeValue(this, 'end', value);\r\n    }\r\n\r\n    get onerror() {\r\n      return getEventAttributeValue(this, 'error');\r\n    }\r\n\r\n    set onerror(value) {\r\n      setEventAttributeValue(this, 'error', value);\r\n    }\r\n\r\n    get onresult() {\r\n      return getEventAttributeValue(this, 'result');\r\n    }\r\n\r\n    set onresult(value) {\r\n      setEventAttributeValue(this, 'result', value);\r\n    }\r\n\r\n    get onsoundend() {\r\n      return getEventAttributeValue(this, 'soundend');\r\n    }\r\n\r\n    set onsoundend(value) {\r\n      setEventAttributeValue(this, 'soundend', value);\r\n    }\r\n\r\n    get onsoundstart() {\r\n      return getEventAttributeValue(this, 'soundstart');\r\n    }\r\n\r\n    set onsoundstart(value) {\r\n      setEventAttributeValue(this, 'soundstart', value);\r\n    }\r\n\r\n    get onspeechend() {\r\n      return getEventAttributeValue(this, 'speechend');\r\n    }\r\n\r\n    set onspeechend(value) {\r\n      setEventAttributeValue(this, 'speechend', value);\r\n    }\r\n\r\n    get onspeechstart() {\r\n      return getEventAttributeValue(this, 'speechstart');\r\n    }\r\n\r\n    set onspeechstart(value) {\r\n      setEventAttributeValue(this, 'speechstart', value);\r\n    }\r\n\r\n    get onstart() {\r\n      return getEventAttributeValue(this, 'start');\r\n    }\r\n\r\n    set onstart(value) {\r\n      setEventAttributeValue(this, 'start', value);\r\n    }\r\n\r\n    start() {\r\n      this._startOnce().catch(err => {\r\n        this.dispatchEvent(new ErrorEvent('error', { error: err, message: err && (err.stack || err.message) }));\r\n      });\r\n    }\r\n\r\n    async _startOnce() {\r\n      // TODO: [P2] Should check if recognition is active, we should not start recognition twice\r\n      const recognizer = await createRecognizer(this.lang);\r\n\r\n      const { pause, unprepare } = prepareAudioConfig(recognizer.audioConfig);\r\n\r\n      try {\r\n        const queue = createPromiseQueue();\r\n        let soundStarted;\r\n        let speechStarted;\r\n        let stopping;\r\n\r\n        const { detach: detachAudioConfigEvent } = recognizer.audioConfig.events.attach(event => {\r\n          const { name } = event;\r\n\r\n          if (name === 'AudioSourceReadyEvent') {\r\n            queue.push({ audioSourceReady: {} });\r\n          } else if (name === 'AudioSourceOffEvent') {\r\n            queue.push({ audioSourceOff: {} });\r\n          } else if (name === 'FirstAudibleChunk') {\r\n            queue.push({ firstAudibleChunk: {} });\r\n          }\r\n        });\r\n\r\n        recognizer.canceled = (_, { errorDetails, offset, reason, sessionId }) => {\r\n          queue.push({\r\n            canceled: {\r\n              errorDetails,\r\n              offset,\r\n              reason,\r\n              sessionId\r\n            }\r\n          });\r\n        };\r\n\r\n        recognizer.recognized = (_, { offset, result, sessionId }) => {\r\n          queue.push({\r\n            recognized: {\r\n              offset,\r\n              result: serializeRecognitionResult(result),\r\n              sessionId\r\n            }\r\n          });\r\n        };\r\n\r\n        recognizer.recognizing = (_, { offset, result, sessionId }) => {\r\n          queue.push({\r\n            recognizing: {\r\n              offset,\r\n              result: serializeRecognitionResult(result),\r\n              sessionId\r\n            }\r\n          });\r\n        };\r\n\r\n        recognizer.sessionStarted = (_, { sessionId }) => {\r\n          queue.push({ sessionStarted: { sessionId } });\r\n        };\r\n\r\n        recognizer.sessionStopped = (_, { sessionId }) => {\r\n          // \"sessionStopped\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\r\n          queue.push({ sessionStopped: { sessionId } });\r\n        };\r\n\r\n        recognizer.speechStartDetected = (_, { offset, sessionId }) => {\r\n          queue.push({ speechStartDetected: { offset, sessionId } });\r\n        };\r\n\r\n        recognizer.speechEndDetected = (_, { sessionId }) => {\r\n          // \"speechEndDetected\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\r\n          // Update: \"speechEndDetected\" is fired for DLSpeech.listenOnceAsync()\r\n          queue.push({ speechEndDetected: { sessionId } });\r\n        };\r\n\r\n        const { phrases } = this.grammars;\r\n\r\n        // HACK: We are using the internal of SpeechRecognizer because they did not expose it\r\n        const { dynamicGrammar } = recognizer.privReco;\r\n\r\n        referenceGrammars && referenceGrammars.length && dynamicGrammar.addReferenceGrammar(referenceGrammars);\r\n        phrases && phrases.length && dynamicGrammar.addPhrase(phrases);\r\n\r\n        await cognitiveServicesAsyncToPromise(recognizer.startContinuousRecognitionAsync.bind(recognizer))();\r\n\r\n        if (recognizer.stopContinuousRecognitionAsync) {\r\n          this.abort = () => queue.push({ abort: {} });\r\n          this.stop = () => queue.push({ stop: {} });\r\n        } else {\r\n          this.abort = this.stop = undefined;\r\n        }\r\n\r\n        let audioStarted;\r\n        let finalEvent;\r\n        let finalizedResults = [];\r\n\r\n        for (let loop = 0; !stopping || audioStarted; loop++) {\r\n          const event = await queue.shift();\r\n          const {\r\n            abort,\r\n            audioSourceOff,\r\n            audioSourceReady,\r\n            canceled,\r\n            firstAudibleChunk,\r\n            recognized,\r\n            recognizing,\r\n            stop\r\n          } = event;\r\n\r\n          // We are emitting event \"cognitiveservices\" for debugging purpose.\r\n          Object.keys(event).forEach(name => this.emitCognitiveServices(name, event[name]));\r\n\r\n          const errorMessage = canceled && canceled.errorDetails;\r\n\r\n          if (/Permission\\sdenied/u.test(errorMessage || '')) {\r\n            // If microphone is not allowed, we should not emit \"start\" event.\r\n\r\n            finalEvent = {\r\n              error: 'not-allowed',\r\n              type: 'error'\r\n            };\r\n\r\n            break;\r\n          }\r\n\r\n          if (!loop) {\r\n            this.dispatchEvent(new SpeechRecognitionEvent('start'));\r\n          }\r\n\r\n          if (errorMessage) {\r\n            if (/1006/u.test(errorMessage)) {\r\n              if (!audioStarted) {\r\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\r\n                this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\r\n              }\r\n\r\n              finalEvent = {\r\n                error: 'network',\r\n                type: 'error'\r\n              };\r\n            } else {\r\n              finalEvent = {\r\n                error: 'unknown',\r\n                type: 'error'\r\n              };\r\n            }\r\n\r\n            break;\r\n          } else if (abort || stop) {\r\n            if (abort) {\r\n              finalEvent = {\r\n                error: 'aborted',\r\n                type: 'error'\r\n              };\r\n\r\n              // If we are aborting, we will ignore lingering recognizing/recognized events. But if we are stopping, we need them.\r\n              stopping = 'abort';\r\n            } else {\r\n              // When we pause, we will send { isEnd: true }, Speech Services will send us \"recognized\" event.\r\n              pause();\r\n              stopping = 'stop';\r\n            }\r\n\r\n            // Abort should not be dispatched without support of \"stopContinuousRecognitionAsync\".\r\n            // But for defensive purpose, we make sure \"stopContinuousRecognitionAsync\" is available before we can call.\r\n            if (abort && recognizer.stopContinuousRecognitionAsync) {\r\n              await cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\r\n            }\r\n          } else if (audioSourceReady) {\r\n            this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\r\n\r\n            audioStarted = true;\r\n          } else if (firstAudibleChunk) {\r\n            this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\r\n\r\n            soundStarted = true;\r\n          } else if (audioSourceOff) {\r\n            // Looks like we don't need this line and all the tests are still working.\r\n            // Guessing probably stopping is already truthy.\r\n            // stopping = true;\r\n\r\n            speechStarted && this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\r\n            soundStarted && this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\r\n            audioStarted && this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\r\n\r\n            audioStarted = soundStarted = speechStarted = false;\r\n\r\n            break;\r\n          } else if (stopping !== 'abort') {\r\n            if (recognized && recognized.result && recognized.result.reason === ResultReason.NoMatch) {\r\n              finalEvent = {\r\n                error: 'no-speech',\r\n                type: 'error'\r\n              };\r\n            } else if (recognized || recognizing) {\r\n              if (!audioStarted) {\r\n                // Unconfirmed prevention of quirks\r\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\r\n\r\n                audioStarted = true;\r\n              }\r\n\r\n              if (!soundStarted) {\r\n                this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\r\n\r\n                soundStarted = true;\r\n              }\r\n\r\n              if (!speechStarted) {\r\n                this.dispatchEvent(new SpeechRecognitionEvent('speechstart'));\r\n\r\n                speechStarted = true;\r\n              }\r\n\r\n              if (recognized) {\r\n                const result = cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognized.result, {\r\n                  maxAlternatives: this.maxAlternatives,\r\n                  textNormalization\r\n                });\r\n\r\n                const recognizable = !!result[0].transcript;\r\n\r\n                if (recognizable) {\r\n                  finalizedResults = [...finalizedResults, result];\r\n\r\n                  this.continuous &&\r\n                    this.dispatchEvent(\r\n                      new SpeechRecognitionEvent('result', {\r\n                        results: finalizedResults\r\n                      })\r\n                    );\r\n                }\r\n\r\n                // If it is continuous, we just sent the finalized results. So we don't need to send it again after \"audioend\" event.\r\n                if (this.continuous && recognizable) {\r\n                  finalEvent = null;\r\n                } else {\r\n                  finalEvent = {\r\n                    results: finalizedResults,\r\n                    type: 'result'\r\n                  };\r\n                }\r\n\r\n                if (!this.continuous && recognizer.stopContinuousRecognitionAsync) {\r\n                  await cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\r\n                }\r\n\r\n                // If event order can be loosened, we can send the recognized event as soon as we receive it.\r\n                // 1. If it is not recognizable (no-speech), we should send an \"error\" event just before \"end\" event. We will not loosen \"error\" events.\r\n                if (looseEvents && finalEvent && recognizable) {\r\n                  this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\r\n                  finalEvent = null;\r\n                }\r\n              } else if (recognizing) {\r\n                this.interimResults &&\r\n                  this.dispatchEvent(\r\n                    new SpeechRecognitionEvent('result', {\r\n                      results: [\r\n                        ...finalizedResults,\r\n                        cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognizing.result, {\r\n                          maxAlternatives: this.maxAlternatives,\r\n                          textNormalization\r\n                        })\r\n                      ]\r\n                    })\r\n                  );\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        if (speechStarted) {\r\n          this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\r\n        }\r\n\r\n        if (soundStarted) {\r\n          this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\r\n        }\r\n\r\n        if (audioStarted) {\r\n          this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\r\n        }\r\n\r\n        if (finalEvent) {\r\n          if (finalEvent.type === 'result' && !finalEvent.results.length) {\r\n            finalEvent = {\r\n              error: 'no-speech',\r\n              type: 'error'\r\n            };\r\n          }\r\n\r\n          if (finalEvent.type === 'error') {\r\n            this.dispatchEvent(new ErrorEvent('error', finalEvent));\r\n          } else {\r\n            this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\r\n          }\r\n        }\r\n\r\n        // Even though there is no \"start\" event emitted, we will still emit \"end\" event\r\n        // This is mainly for \"microphone blocked\" story.\r\n        this.dispatchEvent(new SpeechRecognitionEvent('end'));\r\n\r\n        detachAudioConfigEvent();\r\n      } catch (err) {\r\n        // Logging out the erorr because Speech SDK would fail silently.\r\n        console.error(err);\r\n\r\n        throw err;\r\n      } finally {\r\n        unprepare();\r\n        recognizer.dispose();\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    SpeechGrammarList,\r\n    SpeechRecognition,\r\n    SpeechRecognitionEvent\r\n  };\r\n}\r\n\r\nexport default options => {\r\n  const {\r\n    audioConfig = AudioConfig.fromDefaultMicrophoneInput(),\r\n\r\n    // We set telemetry to true to honor the default telemetry settings of Speech SDK\r\n    // https://github.com/Microsoft/cognitive-services-speech-sdk-js#data--telemetry\r\n    enableTelemetry = true,\r\n\r\n    fetchCredentials,\r\n    looseEvents,\r\n    referenceGrammars,\r\n    speechRecognitionEndpointId,\r\n    textNormalization = 'display'\r\n  } = patchOptions(options);\r\n\r\n  if (!audioConfig && (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia)) {\r\n    console.warn(\r\n      'web-speech-cognitive-services: This browser does not support WebRTC and it will not work with Cognitive Services Speech Services.'\r\n    );\r\n\r\n    return {};\r\n  }\r\n\r\n  const createRecognizer = async lang => {\r\n    const { authorizationToken, region, speechRecognitionHostname, subscriptionKey } = await fetchCredentials();\r\n    let speechConfig;\r\n\r\n    if (speechRecognitionHostname) {\r\n      const host = { hostname: speechRecognitionHostname, port: 443, protocol: 'wss:' };\r\n\r\n      if (authorizationToken) {\r\n        speechConfig = SpeechConfig.fromHost(host);\r\n        speechConfig.authorizationToken = authorizationToken;\r\n      } else {\r\n        speechConfig = SpeechConfig.fromHost(host, subscriptionKey);\r\n      }\r\n    } else {\r\n      speechConfig = authorizationToken\r\n        ? SpeechConfig.fromAuthorizationToken(authorizationToken, region)\r\n        : SpeechConfig.fromSubscription(subscriptionKey, region);\r\n    }\r\n\r\n    if (speechRecognitionEndpointId) {\r\n      speechConfig.endpointId = speechRecognitionEndpointId;\r\n    }\r\n\r\n    speechConfig.outputFormat = OutputFormat.Detailed;\r\n    speechConfig.speechRecognitionLanguage = lang || 'en-US';\r\n\r\n    return new SpeechRecognizer(speechConfig, audioConfig);\r\n  };\r\n\r\n  return createSpeechRecognitionPonyfillFromRecognizer({\r\n    audioConfig,\r\n    createRecognizer,\r\n    enableTelemetry,\r\n    looseEvents,\r\n    referenceGrammars,\r\n    textNormalization\r\n  });\r\n};\r\n","export default function (array, extras) {\r\n  const map = {\r\n    ...[].reduce.call(\r\n      array,\r\n      (map, value, index) => {\r\n        map[index] = value;\r\n\r\n        return map;\r\n      },\r\n      {}\r\n    ),\r\n    ...extras,\r\n    length: array.length,\r\n    [Symbol.iterator]: () => [].slice.call(map)[Symbol.iterator]()\r\n  };\r\n\r\n  return map;\r\n}\r\n","// We are only importing what we need.\r\n\r\nimport {\r\n  AudioConfig,\r\n  OutputFormat,\r\n  ResultReason,\r\n  SpeechConfig,\r\n  SpeechRecognizer\r\n} from 'microsoft-cognitiveservices-speech-sdk/distrib/lib/microsoft.cognitiveservices.speech.sdk';\r\n\r\nexport default {\r\n  AudioConfig,\r\n  OutputFormat,\r\n  ResultReason,\r\n  SpeechConfig,\r\n  SpeechRecognizer\r\n};\r\n","import arrayToMap from '../../Util/arrayToMap';\r\nimport SpeechSDK from '../SpeechSDK';\r\n\r\nconst {\r\n  ResultReason: { RecognizingSpeech, RecognizedSpeech }\r\n} = SpeechSDK;\r\n\r\nexport default function (result, { maxAlternatives = Infinity, textNormalization = 'display' } = {}) {\r\n  if (result.reason === RecognizingSpeech || (result.reason === RecognizedSpeech && !result.json.NBest)) {\r\n    const resultList = [\r\n      {\r\n        confidence: 0.5,\r\n        transcript: result.text\r\n      }\r\n    ];\r\n\r\n    if (result.reason === RecognizedSpeech) {\r\n      resultList.isFinal = true;\r\n    }\r\n\r\n    return resultList;\r\n  } else if (result.reason === RecognizedSpeech) {\r\n    const resultList = arrayToMap(\r\n      (result.json.NBest || [])\r\n        .slice(0, maxAlternatives)\r\n        .map(({ Confidence: confidence, Display: display, ITN: itn, Lexical: lexical, MaskedITN: maskedITN }) => ({\r\n          confidence,\r\n          transcript:\r\n            textNormalization === 'itn'\r\n              ? itn\r\n              : textNormalization === 'lexical'\r\n                ? lexical\r\n                : textNormalization === 'maskeditn'\r\n                  ? maskedITN\r\n                  : display\r\n        })),\r\n      { isFinal: true }\r\n    );\r\n\r\n    return resultList;\r\n  }\r\n\r\n  return [];\r\n}\r\n","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","import createDeferred from 'p-defer';\r\n\r\nexport default function () {\r\n  let shiftDeferred;\r\n  const queue = [];\r\n\r\n  const push = value => {\r\n    if (shiftDeferred) {\r\n      const { resolve } = shiftDeferred;\r\n\r\n      shiftDeferred = null;\r\n      resolve(value);\r\n    } else {\r\n      queue.push(value);\r\n    }\r\n  };\r\n\r\n  const shift = () => {\r\n    if (queue.length) {\r\n      return Promise.resolve(queue.shift());\r\n    }\r\n\r\n    return (shiftDeferred || (shiftDeferred = createDeferred())).promise;\r\n  };\r\n\r\n  return {\r\n    push,\r\n    shift\r\n  };\r\n}\r\n","function isFunction(value: unknown): value is () => unknown {\r\n  return typeof value === 'function';\r\n}\r\n\r\nexport default function resolveFunctionOrReturnValue<T>(\r\n  fnOrValue: (() => Promise<T> | T) | Promise<T> | T\r\n): Promise<T> | T {\r\n  return isFunction(fnOrValue) ? fnOrValue() : fnOrValue;\r\n}\r\n","import resolveFunctionOrReturnValue from './resolveFunctionOrReturnValue';\r\n\r\nlet shouldWarnOnSubscriptionKey = true;\r\n\r\nexport default function patchOptions({\r\n  authorizationToken,\r\n  credentials,\r\n  looseEvent,\r\n  looseEvents,\r\n  region = 'westus',\r\n  subscriptionKey,\r\n  ...otherOptions\r\n} = {}) {\r\n  if (typeof looseEvent !== 'undefined') {\r\n    console.warn('web-speech-cognitive-services: The option \"looseEvent\" should be named as \"looseEvents\".');\r\n\r\n    looseEvents = looseEvent;\r\n  }\r\n\r\n  if (!credentials) {\r\n    if (!authorizationToken && !subscriptionKey) {\r\n      throw new Error('web-speech-cognitive-services: Credentials must be specified.');\r\n    } else {\r\n      console.warn(\r\n        'web-speech-cognitive-services: We are deprecating authorizationToken, region, and subscriptionKey. Please use credentials instead. The deprecated option will be removed on or after 2020-11-14.'\r\n      );\r\n\r\n      credentials = async () =>\r\n        authorizationToken\r\n          ? { authorizationToken: await resolveFunctionOrReturnValue(authorizationToken), region }\r\n          : { region, subscriptionKey: await resolveFunctionOrReturnValue(subscriptionKey) };\r\n    }\r\n  }\r\n\r\n  return {\r\n    ...otherOptions,\r\n    fetchCredentials: async () => {\r\n      const {\r\n        authorizationToken,\r\n        customVoiceHostname,\r\n        region,\r\n        speechRecognitionHostname,\r\n        speechSynthesisHostname,\r\n        subscriptionKey\r\n      } = await resolveFunctionOrReturnValue(credentials);\r\n\r\n      if ((!authorizationToken && !subscriptionKey) || (authorizationToken && subscriptionKey)) {\r\n        throw new Error(\r\n          'web-speech-cognitive-services: Either \"authorizationToken\" or \"subscriptionKey\" must be provided.'\r\n        );\r\n      } else if (!region && !(speechRecognitionHostname && speechSynthesisHostname)) {\r\n        throw new Error(\r\n          'web-speech-cognitive-services: Either \"region\" or \"speechRecognitionHostname\" and \"speechSynthesisHostname\" must be set.'\r\n        );\r\n      } else if (region && (customVoiceHostname || speechRecognitionHostname || speechSynthesisHostname)) {\r\n        throw new Error(\r\n          'web-speech-cognitive-services: Only either \"region\" or \"customVoiceHostname\", \"speechRecognitionHostname\" and \"speechSynthesisHostname\" can be set.'\r\n        );\r\n      } else if (authorizationToken) {\r\n        if (typeof authorizationToken !== 'string') {\r\n          throw new Error('web-speech-cognitive-services: \"authorizationToken\" must be a string.');\r\n        }\r\n      } else if (typeof subscriptionKey !== 'string') {\r\n        throw new Error('web-speech-cognitive-services: \"subscriptionKey\" must be a string.');\r\n      }\r\n\r\n      if (shouldWarnOnSubscriptionKey && subscriptionKey) {\r\n        console.warn(\r\n          'web-speech-cognitive-services: In production environment, subscription key should not be used, authorization token should be used instead.'\r\n        );\r\n\r\n        shouldWarnOnSubscriptionKey = false;\r\n      }\r\n\r\n      const resolvedCredentials = authorizationToken ? { authorizationToken } : { subscriptionKey };\r\n\r\n      if (region) {\r\n        resolvedCredentials.region = region;\r\n      } else {\r\n        resolvedCredentials.customVoiceHostname = customVoiceHostname;\r\n        resolvedCredentials.speechRecognitionHostname = speechRecognitionHostname;\r\n        resolvedCredentials.speechSynthesisHostname = speechSynthesisHostname;\r\n      }\r\n\r\n      return resolvedCredentials;\r\n    },\r\n    looseEvents\r\n  };\r\n}\r\n","/* eslint class-methods-use-this: \"off\" */\r\n\r\nexport default class {\r\n  constructor() {\r\n    this._phrases = [];\r\n  }\r\n\r\n  addFromString() {\r\n    throw new Error('JSGF is not supported');\r\n  }\r\n\r\n  get phrases() {\r\n    return this._phrases;\r\n  }\r\n\r\n  set phrases(value) {\r\n    if (Array.isArray(value)) {\r\n      this._phrases = value;\r\n    } else if (typeof value === 'string') {\r\n      this._phrases = [value];\r\n    } else {\r\n      throw new Error(`The provided value is not an array or of type 'string'`);\r\n    }\r\n  }\r\n}\r\n","import createSpeechRecognitionPonyfill, {\r\n  createSpeechRecognitionPonyfillFromRecognizer\r\n} from './SpeechToText/createSpeechRecognitionPonyfill';\r\n\r\nexport default createSpeechRecognitionPonyfill;\r\n\r\nexport { createSpeechRecognitionPonyfillFromRecognizer };\r\n","/* eslint class-methods-use-this: 0 */\r\n\r\nimport { EventTarget, getEventAttributeValue, setEventAttributeValue } from 'event-target-shim';\r\nimport { onErrorResumeNext } from 'on-error-resume-next/async';\r\nimport createDeferred from 'p-defer';\r\n\r\nimport patchOptions from '../patchOptions';\r\nimport AudioContextQueue from './AudioContextQueue';\r\nimport SpeechSynthesisEvent from './SpeechSynthesisEvent';\r\nimport SpeechSynthesisUtterance from './SpeechSynthesisUtterance';\r\nimport fetchCustomVoices from './fetchCustomVoices';\r\nimport fetchVoices from './fetchVoices';\r\n\r\n// Supported output format can be found at https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/rest-text-to-speech#audio-outputs\r\nconst DEFAULT_OUTPUT_FORMAT = 'audio-24khz-160kbitrate-mono-mp3';\r\nconst EMPTY_ARRAY = [];\r\n\r\nexport default options => {\r\n  const {\r\n    audioContext,\r\n    fetchCredentials,\r\n    ponyfill = {\r\n      AudioContext: window.AudioContext || window.webkitAudioContext\r\n    },\r\n    speechSynthesisDeploymentId,\r\n    speechSynthesisOutputFormat = DEFAULT_OUTPUT_FORMAT\r\n  } = patchOptions(options);\r\n\r\n  if (!audioContext && !ponyfill.AudioContext) {\r\n    console.warn(\r\n      'web-speech-cognitive-services: This browser does not support Web Audio and it will not work with Cognitive Services Speech Services.'\r\n    );\r\n\r\n    return {};\r\n  }\r\n\r\n  class SpeechSynthesis extends EventTarget {\r\n    constructor() {\r\n      super();\r\n\r\n      this.queue = new AudioContextQueue({ audioContext, ponyfill });\r\n\r\n      this.updateVoices();\r\n    }\r\n\r\n    cancel() {\r\n      this.queue.stop();\r\n    }\r\n\r\n    getVoices() {\r\n      return EMPTY_ARRAY;\r\n    }\r\n\r\n    get onvoiceschanged() {\r\n      return getEventAttributeValue(this, 'voiceschanged');\r\n    }\r\n\r\n    set onvoiceschanged(value) {\r\n      setEventAttributeValue(this, 'voiceschanged', value);\r\n    }\r\n\r\n    pause() {\r\n      this.queue.pause();\r\n    }\r\n\r\n    resume() {\r\n      this.queue.resume();\r\n    }\r\n\r\n    speak(utterance) {\r\n      if (!(utterance instanceof SpeechSynthesisUtterance)) {\r\n        throw new Error('invalid utterance');\r\n      }\r\n\r\n      const { reject, resolve, promise } = createDeferred();\r\n      const handleError = ({ error: errorCode, message }) => {\r\n        const error = new Error(errorCode);\r\n\r\n        error.stack = message;\r\n\r\n        reject(error);\r\n      };\r\n\r\n      utterance.addEventListener('end', resolve);\r\n      utterance.addEventListener('error', handleError);\r\n\r\n      utterance.preload({\r\n        deploymentId: speechSynthesisDeploymentId,\r\n        fetchCredentials,\r\n        outputFormat: speechSynthesisOutputFormat\r\n      });\r\n\r\n      this.queue.push(utterance);\r\n\r\n      return promise.finally(() => {\r\n        utterance.removeEventListener('end', resolve);\r\n        utterance.removeEventListener('error', handleError);\r\n      });\r\n    }\r\n\r\n    get speaking() {\r\n      return this.queue.speaking;\r\n    }\r\n\r\n    async updateVoices() {\r\n      const { customVoiceHostname, region, speechSynthesisHostname, subscriptionKey } = await fetchCredentials();\r\n\r\n      if (speechSynthesisDeploymentId) {\r\n        if (subscriptionKey) {\r\n          console.warn(\r\n            'web-speech-cognitive-services: Listing of custom voice models are only available when using subscription key.'\r\n          );\r\n\r\n          await onErrorResumeNext(async () => {\r\n            const voices = await fetchCustomVoices({\r\n              customVoiceHostname,\r\n              deploymentId: speechSynthesisDeploymentId,\r\n              region,\r\n              speechSynthesisHostname,\r\n              subscriptionKey\r\n            });\r\n\r\n            this.getVoices = () => voices;\r\n          });\r\n        }\r\n      } else {\r\n        // If fetch voice list failed, we will not emit \"voiceschanged\" event.\r\n        // In the spec, there is no \"error\" event.\r\n\r\n        await onErrorResumeNext(async () => {\r\n          const voices = await fetchVoices(await fetchCredentials());\r\n\r\n          this.getVoices = () => voices;\r\n        });\r\n      }\r\n\r\n      this.dispatchEvent(new SpeechSynthesisEvent('voiceschanged'));\r\n    }\r\n  }\r\n\r\n  return {\r\n    speechSynthesis: new SpeechSynthesis(),\r\n    SpeechSynthesisEvent,\r\n    SpeechSynthesisUtterance\r\n  };\r\n};\r\n","/* eslint no-await-in-loop: \"off\" */\r\n\r\nimport memoize from 'memoize-one';\r\n\r\nimport AudioContextConsumer from './AudioContextConsumer';\r\n\r\nexport default class {\r\n  constructor({ audioContext, ponyfill }) {\r\n    this.consumer = null;\r\n    this.paused = false;\r\n    this.queue = [];\r\n\r\n    this.getAudioContext = memoize(() => audioContext || new ponyfill.AudioContext());\r\n  }\r\n\r\n  pause() {\r\n    this.paused = true;\r\n    this.consumer && this.consumer.pause();\r\n  }\r\n\r\n  push(utterance) {\r\n    this.queue.push(utterance);\r\n    this.startConsumer();\r\n  }\r\n\r\n  resume() {\r\n    this.paused = false;\r\n\r\n    if (this.consumer) {\r\n      this.consumer.resume();\r\n    } else {\r\n      this.startConsumer();\r\n    }\r\n  }\r\n\r\n  get speaking() {\r\n    return !!this.consumer;\r\n  }\r\n\r\n  async startConsumer() {\r\n    while (!this.paused && this.queue.length && !this.consumer) {\r\n      this.consumer = new AudioContextConsumer(this.getAudioContext());\r\n\r\n      await this.consumer.start(this.queue);\r\n\r\n      this.consumer = null;\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    this.queue.splice(0);\r\n    this.consumer && this.consumer.stop();\r\n  }\r\n}\r\n","/* eslint no-await-in-loop: \"off\" */\r\n\r\nexport default class {\r\n  constructor(audioContext) {\r\n    this.audioContext = audioContext;\r\n  }\r\n\r\n  pause() {\r\n    this.audioContext && this.audioContext.suspend();\r\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('pause'));\r\n  }\r\n\r\n  resume() {\r\n    this.audioContext && this.audioContext.resume();\r\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('resume'));\r\n  }\r\n\r\n  async start(queue) {\r\n    let utterance;\r\n\r\n    while ((utterance = queue.shift())) {\r\n      this.playingUtterance = utterance;\r\n\r\n      await utterance.play(this.audioContext);\r\n\r\n      this.playingUtterance = null;\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    this.playingUtterance && this.playingUtterance.stop();\r\n\r\n    if (this.audioContext.state === 'suspended') {\r\n      // Play -> Pause -> Cancel (stop)\r\n      // This would generate these events: \"start\", \"pause\", \"end\"\r\n\r\n      // Without this code, the \"end\" event will not emit until resume() is called\r\n      // Cancelling an unstarted utterance will not emit any \"start\" or \"end\" event\r\n      this.audioContext.resume();\r\n    }\r\n  }\r\n}\r\n","import { Event } from 'event-target-shim';\r\n\r\nexport default class SpeechSynthesisEvent extends Event {\r\n  constructor(type) {\r\n    super(type);\r\n  }\r\n}\r\n","/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\r\n\r\nimport { EventTarget, getEventAttributeValue, setEventAttributeValue } from 'event-target-shim';\r\nimport EventAsPromise from 'event-as-promise';\r\n\r\nimport fetchSpeechData from './fetchSpeechData';\r\nimport SpeechSynthesisEvent from './SpeechSynthesisEvent';\r\nimport subscribeEvent from './subscribeEvent';\r\n\r\nfunction asyncDecodeAudioData(audioContext, arrayBuffer) {\r\n  return new Promise((resolve, reject) => {\r\n    const promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject);\r\n\r\n    // Newer implementation of \"decodeAudioData\" will return a Promise\r\n    promise && typeof promise.then === 'function' && resolve(promise);\r\n  });\r\n}\r\n\r\nfunction playDecoded(audioContext, audioBuffer, source) {\r\n  return new Promise((resolve, reject) => {\r\n    const audioContextClosed = new EventAsPromise();\r\n    const sourceEnded = new EventAsPromise();\r\n    const unsubscribe = subscribeEvent(\r\n      audioContext,\r\n      'statechange',\r\n      ({ target: { state } }) => state === 'closed' && audioContextClosed.eventListener()\r\n    );\r\n\r\n    try {\r\n      source.buffer = audioBuffer;\r\n      // \"ended\" may not fire if the underlying AudioContext is closed prematurely\r\n      source.onended = sourceEnded.eventListener;\r\n\r\n      source.connect(audioContext.destination);\r\n      source.start(0);\r\n\r\n      Promise.race([audioContextClosed.upcoming(), sourceEnded.upcoming()]).then(resolve);\r\n    } catch (err) {\r\n      reject(err);\r\n    } finally {\r\n      unsubscribe();\r\n    }\r\n  });\r\n}\r\n\r\nclass SpeechSynthesisUtterance extends EventTarget {\r\n  constructor(text) {\r\n    super();\r\n\r\n    this._lang = null;\r\n    this._pitch = 1;\r\n    this._rate = 1;\r\n    this._voice = null;\r\n    this._volume = 1;\r\n\r\n    this.text = text;\r\n\r\n    this.onboundary = null;\r\n    this.onend = null;\r\n    this.onerror = null;\r\n    this.onmark = null;\r\n    this.onpause = null;\r\n    this.onresume = null;\r\n    this.onstart = null;\r\n  }\r\n\r\n  get lang() {\r\n    return this._lang;\r\n  }\r\n\r\n  set lang(value) {\r\n    this._lang = value;\r\n  }\r\n\r\n  get onboundary() {\r\n    return getEventAttributeValue(this, 'boundary');\r\n  }\r\n\r\n  set onboundary(value) {\r\n    setEventAttributeValue(this, 'boundary', value);\r\n  }\r\n\r\n  get onend() {\r\n    return getEventAttributeValue(this, 'end');\r\n  }\r\n\r\n  set onend(value) {\r\n    setEventAttributeValue(this, 'end', value);\r\n  }\r\n\r\n  get onerror() {\r\n    return getEventAttributeValue(this, 'error');\r\n  }\r\n\r\n  set onerror(value) {\r\n    setEventAttributeValue(this, 'error', value);\r\n  }\r\n\r\n  get onmark() {\r\n    return getEventAttributeValue(this, 'mark');\r\n  }\r\n\r\n  set onmark(value) {\r\n    setEventAttributeValue(this, 'mark', value);\r\n  }\r\n\r\n  get onpause() {\r\n    return getEventAttributeValue(this, 'pause');\r\n  }\r\n\r\n  set onpause(value) {\r\n    setEventAttributeValue(this, 'pause', value);\r\n  }\r\n\r\n  get onresume() {\r\n    return getEventAttributeValue(this, 'resume');\r\n  }\r\n\r\n  set onresume(value) {\r\n    setEventAttributeValue(this, 'resume', value);\r\n  }\r\n\r\n  get onstart() {\r\n    return getEventAttributeValue(this, 'start');\r\n  }\r\n\r\n  set onstart(value) {\r\n    setEventAttributeValue(this, 'start', value);\r\n  }\r\n\r\n  get pitch() {\r\n    return this._pitch;\r\n  }\r\n\r\n  set pitch(value) {\r\n    this._pitch = value;\r\n  }\r\n\r\n  get rate() {\r\n    return this._rate;\r\n  }\r\n\r\n  set rate(value) {\r\n    this._rate = value;\r\n  }\r\n\r\n  get voice() {\r\n    return this._voice;\r\n  }\r\n\r\n  set voice(value) {\r\n    this._voice = value;\r\n  }\r\n\r\n  get volume() {\r\n    return this._volume;\r\n  }\r\n\r\n  set volume(value) {\r\n    this._volume = value;\r\n  }\r\n\r\n  preload({ deploymentId, fetchCredentials, outputFormat }) {\r\n    this.arrayBufferPromise = fetchSpeechData({\r\n      fetchCredentials,\r\n      deploymentId,\r\n      lang: this.lang || window.navigator.language,\r\n      outputFormat,\r\n      pitch: this.pitch,\r\n      rate: this.rate,\r\n      text: this.text,\r\n      voice: this.voice && this.voice.voiceURI,\r\n      volume: this.volume\r\n    });\r\n\r\n    // We need to call \"catch\" to make sure the Promise is running.\r\n    // We will ignore the reject result and handled in play() later.\r\n    this.arrayBufferPromise.catch();\r\n  }\r\n\r\n  async play(audioContext) {\r\n    try {\r\n      // We should emit \"start\" event even if preload() failed.\r\n      this.dispatchEvent(new SpeechSynthesisEvent('start'));\r\n\r\n      // HACK: iOS requires bufferSourceNode to be constructed before decoding data.\r\n      const source = audioContext.createBufferSource();\r\n      const audioBuffer = await asyncDecodeAudioData(audioContext, await this.arrayBufferPromise);\r\n\r\n      this._playingSource = source;\r\n\r\n      await playDecoded(audioContext, audioBuffer, source);\r\n\r\n      this._playingSource = null;\r\n      this.dispatchEvent(new SpeechSynthesisEvent('end'));\r\n    } catch (error) {\r\n      // \"message\" is not in spec but to provide a friendly message.\r\n      this.dispatchEvent(new ErrorEvent('error', { error: 'synthesis-failed', message: error.stack }));\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    this._playingSource && this._playingSource.stop();\r\n  }\r\n}\r\n\r\nexport default SpeechSynthesisUtterance;\r\n","import { decode } from 'base64-arraybuffer';\r\nimport buildSSML from './buildSSML';\r\nimport isSSML from './isSSML';\r\n\r\nconst DEFAULT_LANGUAGE = 'en-US';\r\nconst DEFAULT_OUTPUT_FORMAT = 'riff-16khz-16bit-mono-pcm';\r\nconst DEFAULT_VOICE = 'Microsoft Server Speech Text to Speech Voice (en-US, AriaNeural)';\r\nconst EMPTY_MP3_BASE64 =\r\n  'SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU3LjU2LjEwMQAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU3LjY0AAAAAAAAAAAAAAAAJAUHAAAAAAAAAYYoRBqpAAAAAAD/+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EMQpg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';\r\n\r\nexport default async function ({\r\n  deploymentId,\r\n  fetchCredentials,\r\n  lang = DEFAULT_LANGUAGE,\r\n  outputFormat = DEFAULT_OUTPUT_FORMAT,\r\n  pitch,\r\n  rate,\r\n  text,\r\n  voice = DEFAULT_VOICE,\r\n  volume\r\n}) {\r\n  if (!text) {\r\n    // If text is empty, play a short audio clip. This allows developers to easily prime the AudioContext object by playing an empty string.\r\n    return decode(EMPTY_MP3_BASE64);\r\n  }\r\n\r\n  const { authorizationToken, region, speechSynthesisHostname, subscriptionKey } = await fetchCredentials();\r\n\r\n  if ((authorizationToken && subscriptionKey) || (!authorizationToken && !subscriptionKey)) {\r\n    throw new Error('Only \"authorizationToken\" or \"subscriptionKey\" should be set.');\r\n  } else if ((region && speechSynthesisHostname) || (!region && !speechSynthesisHostname)) {\r\n    throw new Error('Only \"region\" or \"speechSynthesisHostnamename\" should be set.');\r\n  }\r\n\r\n  const ssml = isSSML(text) ? text : buildSSML({ lang, pitch, rate, text, voice, volume });\r\n\r\n  // Although calling encodeURI on hostname does not actually works, it fails faster and safer.\r\n  const hostname =\r\n    speechSynthesisHostname ||\r\n    (deploymentId\r\n      ? `${encodeURI(region)}.voice.speech.microsoft.com`\r\n      : `${encodeURI(region)}.tts.speech.microsoft.com`);\r\n  const search = deploymentId ? `?deploymentId=${encodeURI(deploymentId)}` : '';\r\n  const url = `https://${hostname}/cognitiveservices/v1${search}`;\r\n\r\n  const res = await fetch(url, {\r\n    headers: {\r\n      'Content-Type': 'application/ssml+xml',\r\n      'X-Microsoft-OutputFormat': outputFormat,\r\n      ...(authorizationToken\r\n        ? {\r\n            Authorization: `Bearer ${authorizationToken}`\r\n          }\r\n        : {\r\n            'Ocp-Apim-Subscription-Key': subscriptionKey\r\n          })\r\n    },\r\n    method: 'POST',\r\n    body: ssml\r\n  });\r\n\r\n  if (!res.ok) {\r\n    throw new Error(`web-speech-cognitive-services: Failed to syntheis speech, server returned ${res.status}`);\r\n  }\r\n\r\n  return res.arrayBuffer();\r\n}\r\n","/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, 100] }] */\r\n\r\n// Cognitive Services does not support unsigned percentage\r\n// It must be converted into +/- first.\r\nfunction relativePercentage(value) {\r\n  let relative = Math.round((value - 1) * 100);\r\n\r\n  if (relative >= 0) {\r\n    relative = '+' + relative;\r\n  }\r\n\r\n  return relative + '%';\r\n}\r\n\r\nexport default function buildSSML({ lang, pitch = 1, rate = 1, text, voice, volume }) {\r\n  return `<speak version=\"1.0\" xml:lang=\"${lang}\">\r\n  <voice xml:lang=\"${lang}\" name=\"${voice}\">\r\n    <prosody pitch=\"${relativePercentage(pitch)}\" rate=\"${relativePercentage(rate)}\" volume=\"${relativePercentage(\r\n      volume\r\n    )}\">\r\n      ${text}\r\n    </prosody>\r\n  </voice>\r\n</speak>`;\r\n}\r\n","const SPEAK_TAG_PATTERN = /^\\s*<speak(\\s|\\/?>)/u;\r\nconst XML_PROLOG_PATTERN = /^\\s*<\\?xml\\s/u;\r\n\r\nexport default function isSSML(text) {\r\n  return SPEAK_TAG_PATTERN.test(text) || XML_PROLOG_PATTERN.test(text);\r\n}\r\n","export default function subscribeEvent(target, name, handler) {\r\n  target.addEventListener(name, handler);\r\n\r\n  return () => target.removeEventListener(name, handler);\r\n}\r\n","export default class {\r\n  constructor({ gender, lang, voiceURI }) {\r\n    this._default = false;\r\n    this._gender = gender;\r\n    this._lang = lang;\r\n    this._localService = false;\r\n    this._name = voiceURI;\r\n    this._voiceURI = voiceURI;\r\n  }\r\n\r\n  get default() {\r\n    return this._default;\r\n  }\r\n\r\n  get gender() {\r\n    return this._gender;\r\n  }\r\n\r\n  get lang() {\r\n    return this._lang;\r\n  }\r\n\r\n  get localService() {\r\n    return this._localService;\r\n  }\r\n\r\n  get name() {\r\n    return this._name;\r\n  }\r\n\r\n  get voiceURI() {\r\n    return this._voiceURI;\r\n  }\r\n}\r\n","/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, -1] }] */\r\n\r\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\r\n\r\nasync function fetchCustomVoices({ customVoiceHostname, deploymentId, region, subscriptionKey }) {\r\n  const hostname = customVoiceHostname || `${region}.customvoice.api.speech.microsoft.com`;\r\n\r\n  // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\r\n  const res = await fetch(\r\n    `https://${encodeURI(hostname)}/api/texttospeech/v2.0/endpoints/${encodeURIComponent(deploymentId)}`,\r\n    {\r\n      headers: {\r\n        accept: 'application/json',\r\n        'ocp-apim-subscription-key': subscriptionKey\r\n      }\r\n    }\r\n  );\r\n\r\n  if (!res.ok) {\r\n    throw new Error('Failed to fetch custom voices');\r\n  }\r\n\r\n  return res.json();\r\n}\r\n\r\nexport default async function ({ customVoiceHostname, deploymentId, region, subscriptionKey }) {\r\n  const { models } = await fetchCustomVoices({ customVoiceHostname, deploymentId, region, subscriptionKey });\r\n\r\n  return models\r\n    .map(\r\n      ({ properties: { Gender: gender }, locale: lang, name: voiceURI }) =>\r\n        new SpeechSynthesisVoice({ gender, lang, voiceURI })\r\n    )\r\n    .sort(({ name: x }, { name: y }) => (x > y ? 1 : x < y ? -1 : 0));\r\n}\r\n","/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, -1] }] */\r\n\r\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\r\n\r\nexport default async function fetchVoices({ authorizationToken, region, speechSynthesisHostname, subscriptionKey }) {\r\n  // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\r\n  const hostname = speechSynthesisHostname || `${encodeURI(region)}.tts.speech.microsoft.com`;\r\n  const res = await fetch(`https://${hostname}/cognitiveservices/voices/list`, {\r\n    headers: {\r\n      'content-type': 'application/json',\r\n      ...(authorizationToken\r\n        ? {\r\n            authorization: `Bearer ${authorizationToken}`\r\n          }\r\n        : {\r\n            'Ocp-Apim-Subscription-Key': subscriptionKey\r\n          })\r\n    }\r\n  });\r\n\r\n  if (!res.ok) {\r\n    throw new Error('Failed to fetch voices');\r\n  }\r\n\r\n  const voices = await res.json();\r\n\r\n  return voices\r\n    .map(({ Gender: gender, Locale: lang, Name: voiceURI }) => new SpeechSynthesisVoice({ gender, lang, voiceURI }))\r\n    .sort(({ name: x }, { name: y }) => (x > y ? 1 : x < y ? -1 : 0));\r\n}\r\n","import createSpeechSynthesisPonyfill from './TextToSpeech/createSpeechSynthesisPonyfill';\r\n\r\nexport default createSpeechSynthesisPonyfill;\r\n","const TOKEN_URL_TEMPLATE = 'https://{region}.api.cognitive.microsoft.com/sts/v1.0/issueToken';\r\n\r\nexport default async function ({ region, subscriptionKey }) {\r\n  const res = await fetch(TOKEN_URL_TEMPLATE.replace(/\\{region\\}/u, region), {\r\n    headers: {\r\n      'Ocp-Apim-Subscription-Key': subscriptionKey\r\n    },\r\n    method: 'POST'\r\n  });\r\n\r\n  if (!res.ok) {\r\n    throw new Error(`Failed to fetch authorization token, server returned ${res.status}`);\r\n  }\r\n\r\n  return res.text();\r\n}\r\n","/* global process */\r\n\r\nimport createSpeechRecognitionPonyfill, {\r\n  createSpeechRecognitionPonyfillFromRecognizer\r\n} from './SpeechServices/SpeechToText';\r\nimport createSpeechSynthesisPonyfill from './SpeechServices/TextToSpeech';\r\nimport fetchAuthorizationToken from './SpeechServices/fetchAuthorizationToken';\r\n\r\nexport default function createSpeechServicesPonyfill(options = {}, ...args) {\r\n  return {\r\n    ...createSpeechRecognitionPonyfill(options, ...args),\r\n    ...createSpeechSynthesisPonyfill(options, ...args)\r\n  };\r\n}\r\n\r\nexport {\r\n  createSpeechRecognitionPonyfill,\r\n  createSpeechRecognitionPonyfillFromRecognizer,\r\n  createSpeechSynthesisPonyfill,\r\n  fetchAuthorizationToken\r\n};\r\n"],"mappings":";AAMA,SAAS,OAAO,aAAa,wBAAwB,8BAA8B;;;ACNpE,SAAR,mBAAkB,OAAO,QAAQ;AACtC,QAAM,MAAM;AAAA,IACV,GAAG,CAAC,EAAE,OAAO;AAAA,MACX;AAAA,MACA,CAACA,MAAK,OAAO,UAAU;AACrB,QAAAA,KAAI,KAAK,IAAI;AAEb,eAAOA;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAAA,IACA,GAAG;AAAA,IACH,QAAQ,MAAM;AAAA,IACd,CAAC,OAAO,QAAQ,GAAG,MAAM,CAAC,EAAE,MAAM,KAAK,GAAG,EAAE,OAAO,QAAQ,EAAE;AAAA,EAC/D;AAEA,SAAO;AACT;;;ACfA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,IAAO,oBAAQ;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ACbA,IAAM;AAAA,EACJ,cAAc,EAAE,mBAAmB,iBAAiB;AACtD,IAAI;AAEW,SAAR,oEAAkB,QAAQ,EAAE,kBAAkB,UAAU,oBAAoB,UAAU,IAAI,CAAC,GAAG;AACnG,MAAI,OAAO,WAAW,qBAAsB,OAAO,WAAW,oBAAoB,CAAC,OAAO,KAAK,OAAQ;AACrG,UAAM,aAAa;AAAA,MACjB;AAAA,QACE,YAAY;AAAA,QACZ,YAAY,OAAO;AAAA,MACrB;AAAA,IACF;AAEA,QAAI,OAAO,WAAW,kBAAkB;AACtC,iBAAW,UAAU;AAAA,IACvB;AAEA,WAAO;AAAA,EACT,WAAW,OAAO,WAAW,kBAAkB;AAC7C,UAAM,aAAa;AAAA,OAChB,OAAO,KAAK,SAAS,CAAC,GACpB,MAAM,GAAG,eAAe,EACxB,IAAI,CAAC,EAAE,YAAY,YAAY,SAAS,SAAS,KAAK,KAAK,SAAS,SAAS,WAAW,UAAU,OAAO;AAAA,QACxG;AAAA,QACA,YACE,sBAAsB,QAClB,MACA,sBAAsB,YACpB,UACA,sBAAsB,cACpB,YACA;AAAA,MACZ,EAAE;AAAA,MACJ,EAAE,SAAS,KAAK;AAAA,IAClB;AAEA,WAAO;AAAA,EACT;AAEA,SAAO,CAAC;AACV;;;AC3Ce,SAAR,SAA0B;AAChC,QAAM,WAAW,CAAC;AAElB,WAAS,UAAU,IAAI,QAAQ,CAAC,SAAS,WAAW;AACnD,aAAS,UAAU;AACnB,aAAS,SAAS;AAAA,EACnB,CAAC;AAED,SAAO;AACR;;;ACPe,SAAR,6BAAoB;AACzB,MAAI;AACJ,QAAM,QAAQ,CAAC;AAEf,QAAM,OAAO,WAAS;AACpB,QAAI,eAAe;AACjB,YAAM,EAAE,QAAQ,IAAI;AAEpB,sBAAgB;AAChB,cAAQ,KAAK;AAAA,IACf,OAAO;AACL,YAAM,KAAK,KAAK;AAAA,IAClB;AAAA,EACF;AAEA,QAAM,QAAQ,MAAM;AAClB,QAAI,MAAM,QAAQ;AAChB,aAAO,QAAQ,QAAQ,MAAM,MAAM,CAAC;AAAA,IACtC;AAEA,YAAQ,kBAAkB,gBAAgB,OAAe,IAAI;AAAA,EAC/D;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;;;AC7BA,SAAS,WAAW,OAAwC;AAC1D,SAAO,OAAO,UAAU;AAC1B;AAEe,SAAR,6BACL,WACgB;AAChB,SAAO,WAAW,SAAS,IAAI,UAAU,IAAI;AAC/C;;;ACNA,IAAI,8BAA8B;AAEnB,SAAR,aAA8B;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS;AAAA,EACT;AAAA,EACA,GAAG;AACL,IAAI,CAAC,GAAG;AACN,MAAI,OAAO,eAAe,aAAa;AACrC,YAAQ,KAAK,0FAA0F;AAEvG,kBAAc;AAAA,EAChB;AAEA,MAAI,CAAC,aAAa;AAChB,QAAI,CAAC,sBAAsB,CAAC,iBAAiB;AAC3C,YAAM,IAAI,MAAM,+DAA+D;AAAA,IACjF,OAAO;AACL,cAAQ;AAAA,QACN;AAAA,MACF;AAEA,oBAAc,YACZ,qBACI,EAAE,oBAAoB,MAAM,6BAA6B,kBAAkB,GAAG,OAAO,IACrF,EAAE,QAAQ,iBAAiB,MAAM,6BAA6B,eAAe,EAAE;AAAA,IACvF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,kBAAkB,YAAY;AAC5B,YAAM;AAAA,QACJ,oBAAAC;AAAA,QACA;AAAA,QACA,QAAAC;AAAA,QACA;AAAA,QACA;AAAA,QACA,iBAAAC;AAAA,MACF,IAAI,MAAM,6BAA6B,WAAW;AAElD,UAAK,CAACF,uBAAsB,CAACE,oBAAqBF,uBAAsBE,kBAAkB;AACxF,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF,WAAW,CAACD,WAAU,EAAE,6BAA6B,0BAA0B;AAC7E,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF,WAAWA,YAAW,uBAAuB,6BAA6B,0BAA0B;AAClG,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF,WAAWD,qBAAoB;AAC7B,YAAI,OAAOA,wBAAuB,UAAU;AAC1C,gBAAM,IAAI,MAAM,uEAAuE;AAAA,QACzF;AAAA,MACF,WAAW,OAAOE,qBAAoB,UAAU;AAC9C,cAAM,IAAI,MAAM,oEAAoE;AAAA,MACtF;AAEA,UAAI,+BAA+BA,kBAAiB;AAClD,gBAAQ;AAAA,UACN;AAAA,QACF;AAEA,sCAA8B;AAAA,MAChC;AAEA,YAAM,sBAAsBF,sBAAqB,EAAE,oBAAAA,oBAAmB,IAAI,EAAE,iBAAAE,iBAAgB;AAE5F,UAAID,SAAQ;AACV,4BAAoB,SAASA;AAAA,MAC/B,OAAO;AACL,4BAAoB,sBAAsB;AAC1C,4BAAoB,4BAA4B;AAChD,4BAAoB,0BAA0B;AAAA,MAChD;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;;;ACtFA,IAAO,4BAAP,MAAqB;AAAA,EACnB,cAAc;AACZ,SAAK,WAAW,CAAC;AAAA,EACnB;AAAA,EAEA,gBAAgB;AACd,UAAM,IAAI,MAAM,uBAAuB;AAAA,EACzC;AAAA,EAEA,IAAI,UAAU;AACZ,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,QAAQ,OAAO;AACjB,QAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAK,WAAW;AAAA,IAClB,WAAW,OAAO,UAAU,UAAU;AACpC,WAAK,WAAW,CAAC,KAAK;AAAA,IACxB,OAAO;AACL,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAAA,EACF;AACF;;;ARYA,IAAM,EAAE,aAAAE,cAAa,cAAAC,eAAc,cAAAC,eAAc,cAAAC,eAAc,kBAAAC,kBAAiB,IAAI;AAEpF,SAAS,2BAA2B,EAAE,UAAU,cAAc,MAAM,QAAQ,YAAY,QAAQ,UAAU,KAAK,GAAG;AAChH,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,MAAM,KAAK,MAAM,IAAI;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,iBAAiB,aAAa;AACrC,QAAM,QAAQ,IAAI,WAAW,WAAW;AAExC,SACE,CAAC,EAAE,OAAO,KAAK,OAAO,CAACC,mBAAkB,cAAcA,oBAAmB,KAAK,IAAI,SAAS,GAAG,CAAC,IAAI,MAAM;AAE9G;AAEA,SAAS,gCAAgC,IAAI;AAC3C,SAAO,IAAI,SAAS,IAAI,QAAQ,CAAC,SAAS,WAAW,GAAG,GAAG,MAAM,SAAS,MAAM,CAAC;AACnF;AAEA,IAAM,yBAAN,cAAqC,MAAM;AAAA,EACzC,YAAY,MAAM,EAAE,MAAM,MAAM,gBAAgB,aAAa,QAAQ,IAAI,CAAC,GAAG;AAC3E,UAAM,IAAI;AAEV,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,iBAAiB;AACtB,SAAK,cAAc;AACnB,SAAK,UAAU;AAAA,EACjB;AACF;AAEA,SAAS,mBAAmB,aAAa;AACvC,QAAM,iBAAiB,YAAY;AACnC,QAAM,sBAAsB,YAAY,OAAO,KAAK,WAAW;AAC/D,MAAI;AACJ,MAAI;AAIJ,cAAY,SAAS,YAAY;AAC/B,UAAM,SAAS,MAAM,oBAAoB;AAEzC,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM,YAAY;AAChB,cAAM,QAAQ,MAAM,OAAO,KAAK;AAQhC,YAAI,CAAC,cAAc,iBAAiB,MAAM,MAAM,IAAI,KAAK;AACvD,sBAAY,OAAO,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AACxD,uBAAa;AAAA,QACf;AAEA,YAAI,OAAO;AACT,iBAAO,EAAE,QAAQ,IAAI,YAAY,CAAC,GAAG,OAAO,MAAM,cAAc,KAAK,IAAI,EAAE;AAAA,QAC7E;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA,OAAO,MAAM;AACX,cAAQ;AAAA,IACV;AAAA,IACA,WAAW,MAAM;AACf,kBAAY,SAAS;AAAA,IACvB;AAAA,EACF;AACF;AAEO,SAAS,8CAA8C;AAAA,EAC5D;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAG;AAED,EAAAD,kBAAiB,gBAAgB,oBAAoB,KAAK;AAAA,EAE1D,MAAM,0BAA0B,YAAY;AAAA,IAC1C,cAAc;AACZ,YAAM;AAEN,WAAK,cAAc;AACnB,WAAK,kBAAkB;AACvB,WAAK,QACH,OAAO,WAAW,cACd,OAAO,SAAS,gBAAgB,aAAa,MAAM,KAAK,OAAO,UAAU,WACzE;AACN,WAAK,YAAY,IAAI,0BAAkB;AACvC,WAAK,mBAAmB;AAAA,IAC1B;AAAA,IAEA,sBAAsB,MAAM,OAAO;AACjC,WAAK;AAAA,QACH,IAAI,uBAAuB,qBAAqB;AAAA,UAC9C,MAAM;AAAA,YACJ,GAAG;AAAA,YACH;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IAEA,IAAI,aAAa;AACf,aAAO,KAAK;AAAA,IACd;AAAA,IAEA,IAAI,WAAW,OAAO;AACpB,WAAK,cAAc;AAAA,IACrB;AAAA,IAEA,IAAI,WAAW;AACb,aAAO,KAAK;AAAA,IACd;AAAA,IAEA,IAAI,SAAS,OAAO;AAClB,UAAI,iBAAiB,2BAAmB;AACtC,aAAK,YAAY;AAAA,MACnB,OAAO;AACL,cAAM,IAAI,MAAM,uDAAuD;AAAA,MACzE;AAAA,IACF;AAAA,IAEA,IAAI,iBAAiB;AACnB,aAAO,KAAK;AAAA,IACd;AAAA,IAEA,IAAI,eAAe,OAAO;AACxB,WAAK,kBAAkB;AAAA,IACzB;AAAA,IAEA,IAAI,kBAAkB;AACpB,aAAO,KAAK;AAAA,IACd;AAAA,IAEA,IAAI,gBAAgB,OAAO;AACzB,WAAK,mBAAmB;AAAA,IAC1B;AAAA,IAEA,IAAI,OAAO;AACT,aAAO,KAAK;AAAA,IACd;AAAA,IAEA,IAAI,KAAK,OAAO;AACd,WAAK,QAAQ;AAAA,IACf;AAAA,IAEA,IAAI,aAAa;AACf,aAAO,uBAAuB,MAAM,UAAU;AAAA,IAChD;AAAA,IAEA,IAAI,WAAW,OAAO;AACpB,6BAAuB,MAAM,YAAY,KAAK;AAAA,IAChD;AAAA,IAEA,IAAI,eAAe;AACjB,aAAO,uBAAuB,MAAM,YAAY;AAAA,IAClD;AAAA,IAEA,IAAI,aAAa,OAAO;AACtB,6BAAuB,MAAM,cAAc,KAAK;AAAA,IAClD;AAAA,IAEA,IAAI,sBAAsB;AACxB,aAAO,uBAAuB,MAAM,mBAAmB;AAAA,IACzD;AAAA,IAEA,IAAI,oBAAoB,OAAO;AAC7B,6BAAuB,MAAM,qBAAqB,KAAK;AAAA,IACzD;AAAA,IAEA,IAAI,QAAQ;AACV,aAAO,uBAAuB,MAAM,KAAK;AAAA,IAC3C;AAAA,IAEA,IAAI,MAAM,OAAO;AACf,6BAAuB,MAAM,OAAO,KAAK;AAAA,IAC3C;AAAA,IAEA,IAAI,UAAU;AACZ,aAAO,uBAAuB,MAAM,OAAO;AAAA,IAC7C;AAAA,IAEA,IAAI,QAAQ,OAAO;AACjB,6BAAuB,MAAM,SAAS,KAAK;AAAA,IAC7C;AAAA,IAEA,IAAI,WAAW;AACb,aAAO,uBAAuB,MAAM,QAAQ;AAAA,IAC9C;AAAA,IAEA,IAAI,SAAS,OAAO;AAClB,6BAAuB,MAAM,UAAU,KAAK;AAAA,IAC9C;AAAA,IAEA,IAAI,aAAa;AACf,aAAO,uBAAuB,MAAM,UAAU;AAAA,IAChD;AAAA,IAEA,IAAI,WAAW,OAAO;AACpB,6BAAuB,MAAM,YAAY,KAAK;AAAA,IAChD;AAAA,IAEA,IAAI,eAAe;AACjB,aAAO,uBAAuB,MAAM,YAAY;AAAA,IAClD;AAAA,IAEA,IAAI,aAAa,OAAO;AACtB,6BAAuB,MAAM,cAAc,KAAK;AAAA,IAClD;AAAA,IAEA,IAAI,cAAc;AAChB,aAAO,uBAAuB,MAAM,WAAW;AAAA,IACjD;AAAA,IAEA,IAAI,YAAY,OAAO;AACrB,6BAAuB,MAAM,aAAa,KAAK;AAAA,IACjD;AAAA,IAEA,IAAI,gBAAgB;AAClB,aAAO,uBAAuB,MAAM,aAAa;AAAA,IACnD;AAAA,IAEA,IAAI,cAAc,OAAO;AACvB,6BAAuB,MAAM,eAAe,KAAK;AAAA,IACnD;AAAA,IAEA,IAAI,UAAU;AACZ,aAAO,uBAAuB,MAAM,OAAO;AAAA,IAC7C;AAAA,IAEA,IAAI,QAAQ,OAAO;AACjB,6BAAuB,MAAM,SAAS,KAAK;AAAA,IAC7C;AAAA,IAEA,QAAQ;AACN,WAAK,WAAW,EAAE,MAAM,SAAO;AAC7B,aAAK,cAAc,IAAI,WAAW,SAAS,EAAE,OAAO,KAAK,SAAS,QAAQ,IAAI,SAAS,IAAI,SAAS,CAAC,CAAC;AAAA,MACxG,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,aAAa;AAEjB,YAAM,aAAa,MAAM,iBAAiB,KAAK,IAAI;AAEnD,YAAM,EAAE,OAAO,UAAU,IAAI,mBAAmB,WAAW,WAAW;AAEtE,UAAI;AACF,cAAM,QAAQ,2BAAmB;AACjC,YAAI;AACJ,YAAI;AACJ,YAAI;AAEJ,cAAM,EAAE,QAAQ,uBAAuB,IAAI,WAAW,YAAY,OAAO,OAAO,WAAS;AACvF,gBAAM,EAAE,KAAK,IAAI;AAEjB,cAAI,SAAS,yBAAyB;AACpC,kBAAM,KAAK,EAAE,kBAAkB,CAAC,EAAE,CAAC;AAAA,UACrC,WAAW,SAAS,uBAAuB;AACzC,kBAAM,KAAK,EAAE,gBAAgB,CAAC,EAAE,CAAC;AAAA,UACnC,WAAW,SAAS,qBAAqB;AACvC,kBAAM,KAAK,EAAE,mBAAmB,CAAC,EAAE,CAAC;AAAA,UACtC;AAAA,QACF,CAAC;AAED,mBAAW,WAAW,CAAC,GAAG,EAAE,cAAc,QAAQ,QAAQ,UAAU,MAAM;AACxE,gBAAM,KAAK;AAAA,YACT,UAAU;AAAA,cACR;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAEA,mBAAW,aAAa,CAAC,GAAG,EAAE,QAAQ,QAAQ,UAAU,MAAM;AAC5D,gBAAM,KAAK;AAAA,YACT,YAAY;AAAA,cACV;AAAA,cACA,QAAQ,2BAA2B,MAAM;AAAA,cACzC;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAEA,mBAAW,cAAc,CAAC,GAAG,EAAE,QAAQ,QAAQ,UAAU,MAAM;AAC7D,gBAAM,KAAK;AAAA,YACT,aAAa;AAAA,cACX;AAAA,cACA,QAAQ,2BAA2B,MAAM;AAAA,cACzC;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAEA,mBAAW,iBAAiB,CAAC,GAAG,EAAE,UAAU,MAAM;AAChD,gBAAM,KAAK,EAAE,gBAAgB,EAAE,UAAU,EAAE,CAAC;AAAA,QAC9C;AAEA,mBAAW,iBAAiB,CAAC,GAAG,EAAE,UAAU,MAAM;AAEhD,gBAAM,KAAK,EAAE,gBAAgB,EAAE,UAAU,EAAE,CAAC;AAAA,QAC9C;AAEA,mBAAW,sBAAsB,CAAC,GAAG,EAAE,QAAQ,UAAU,MAAM;AAC7D,gBAAM,KAAK,EAAE,qBAAqB,EAAE,QAAQ,UAAU,EAAE,CAAC;AAAA,QAC3D;AAEA,mBAAW,oBAAoB,CAAC,GAAG,EAAE,UAAU,MAAM;AAGnD,gBAAM,KAAK,EAAE,mBAAmB,EAAE,UAAU,EAAE,CAAC;AAAA,QACjD;AAEA,cAAM,EAAE,QAAQ,IAAI,KAAK;AAGzB,cAAM,EAAE,eAAe,IAAI,WAAW;AAEtC,6BAAqB,kBAAkB,UAAU,eAAe,oBAAoB,iBAAiB;AACrG,mBAAW,QAAQ,UAAU,eAAe,UAAU,OAAO;AAE7D,cAAM,gCAAgC,WAAW,gCAAgC,KAAK,UAAU,CAAC,EAAE;AAEnG,YAAI,WAAW,gCAAgC;AAC7C,eAAK,QAAQ,MAAM,MAAM,KAAK,EAAE,OAAO,CAAC,EAAE,CAAC;AAC3C,eAAK,OAAO,MAAM,MAAM,KAAK,EAAE,MAAM,CAAC,EAAE,CAAC;AAAA,QAC3C,OAAO;AACL,eAAK,QAAQ,KAAK,OAAO;AAAA,QAC3B;AAEA,YAAI;AACJ,YAAI;AACJ,YAAI,mBAAmB,CAAC;AAExB,iBAAS,OAAO,GAAG,CAAC,YAAY,cAAc,QAAQ;AACpD,gBAAM,QAAQ,MAAM,MAAM,MAAM;AAChC,gBAAM;AAAA,YACJ;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,IAAI;AAGJ,iBAAO,KAAK,KAAK,EAAE,QAAQ,UAAQ,KAAK,sBAAsB,MAAM,MAAM,IAAI,CAAC,CAAC;AAEhF,gBAAM,eAAe,YAAY,SAAS;AAE1C,cAAI,sBAAsB,KAAK,gBAAgB,EAAE,GAAG;AAGlD,yBAAa;AAAA,cACX,OAAO;AAAA,cACP,MAAM;AAAA,YACR;AAEA;AAAA,UACF;AAEA,cAAI,CAAC,MAAM;AACT,iBAAK,cAAc,IAAI,uBAAuB,OAAO,CAAC;AAAA,UACxD;AAEA,cAAI,cAAc;AAChB,gBAAI,QAAQ,KAAK,YAAY,GAAG;AAC9B,kBAAI,CAAC,cAAc;AACjB,qBAAK,cAAc,IAAI,uBAAuB,YAAY,CAAC;AAC3D,qBAAK,cAAc,IAAI,uBAAuB,UAAU,CAAC;AAAA,cAC3D;AAEA,2BAAa;AAAA,gBACX,OAAO;AAAA,gBACP,MAAM;AAAA,cACR;AAAA,YACF,OAAO;AACL,2BAAa;AAAA,gBACX,OAAO;AAAA,gBACP,MAAM;AAAA,cACR;AAAA,YACF;AAEA;AAAA,UACF,WAAW,SAAS,MAAM;AACxB,gBAAI,OAAO;AACT,2BAAa;AAAA,gBACX,OAAO;AAAA,gBACP,MAAM;AAAA,cACR;AAGA,yBAAW;AAAA,YACb,OAAO;AAEL,oBAAM;AACN,yBAAW;AAAA,YACb;AAIA,gBAAI,SAAS,WAAW,gCAAgC;AACtD,oBAAM,gCAAgC,WAAW,+BAA+B,KAAK,UAAU,CAAC,EAAE;AAAA,YACpG;AAAA,UACF,WAAW,kBAAkB;AAC3B,iBAAK,cAAc,IAAI,uBAAuB,YAAY,CAAC;AAE3D,2BAAe;AAAA,UACjB,WAAW,mBAAmB;AAC5B,iBAAK,cAAc,IAAI,uBAAuB,YAAY,CAAC;AAE3D,2BAAe;AAAA,UACjB,WAAW,gBAAgB;AAKzB,6BAAiB,KAAK,cAAc,IAAI,uBAAuB,WAAW,CAAC;AAC3E,4BAAgB,KAAK,cAAc,IAAI,uBAAuB,UAAU,CAAC;AACzE,4BAAgB,KAAK,cAAc,IAAI,uBAAuB,UAAU,CAAC;AAEzE,2BAAe,eAAe,gBAAgB;AAE9C;AAAA,UACF,WAAW,aAAa,SAAS;AAC/B,gBAAI,cAAc,WAAW,UAAU,WAAW,OAAO,WAAWF,cAAa,SAAS;AACxF,2BAAa;AAAA,gBACX,OAAO;AAAA,gBACP,MAAM;AAAA,cACR;AAAA,YACF,WAAW,cAAc,aAAa;AACpC,kBAAI,CAAC,cAAc;AAEjB,qBAAK,cAAc,IAAI,uBAAuB,YAAY,CAAC;AAE3D,+BAAe;AAAA,cACjB;AAEA,kBAAI,CAAC,cAAc;AACjB,qBAAK,cAAc,IAAI,uBAAuB,YAAY,CAAC;AAE3D,+BAAe;AAAA,cACjB;AAEA,kBAAI,CAAC,eAAe;AAClB,qBAAK,cAAc,IAAI,uBAAuB,aAAa,CAAC;AAE5D,gCAAgB;AAAA,cAClB;AAEA,kBAAI,YAAY;AACd,sBAAM,SAAS,oEAA4D,WAAW,QAAQ;AAAA,kBAC5F,iBAAiB,KAAK;AAAA,kBACtB;AAAA,gBACF,CAAC;AAED,sBAAM,eAAe,CAAC,CAAC,OAAO,CAAC,EAAE;AAEjC,oBAAI,cAAc;AAChB,qCAAmB,CAAC,GAAG,kBAAkB,MAAM;AAE/C,uBAAK,cACH,KAAK;AAAA,oBACH,IAAI,uBAAuB,UAAU;AAAA,sBACnC,SAAS;AAAA,oBACX,CAAC;AAAA,kBACH;AAAA,gBACJ;AAGA,oBAAI,KAAK,cAAc,cAAc;AACnC,+BAAa;AAAA,gBACf,OAAO;AACL,+BAAa;AAAA,oBACX,SAAS;AAAA,oBACT,MAAM;AAAA,kBACR;AAAA,gBACF;AAEA,oBAAI,CAAC,KAAK,cAAc,WAAW,gCAAgC;AACjE,wBAAM,gCAAgC,WAAW,+BAA+B,KAAK,UAAU,CAAC,EAAE;AAAA,gBACpG;AAIA,oBAAI,eAAe,cAAc,cAAc;AAC7C,uBAAK,cAAc,IAAI,uBAAuB,WAAW,MAAM,UAAU,CAAC;AAC1E,+BAAa;AAAA,gBACf;AAAA,cACF,WAAW,aAAa;AACtB,qBAAK,kBACH,KAAK;AAAA,kBACH,IAAI,uBAAuB,UAAU;AAAA,oBACnC,SAAS;AAAA,sBACP,GAAG;AAAA,sBACH,oEAA4D,YAAY,QAAQ;AAAA,wBAC9E,iBAAiB,KAAK;AAAA,wBACtB;AAAA,sBACF,CAAC;AAAA,oBACH;AAAA,kBACF,CAAC;AAAA,gBACH;AAAA,cACJ;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,YAAI,eAAe;AACjB,eAAK,cAAc,IAAI,uBAAuB,WAAW,CAAC;AAAA,QAC5D;AAEA,YAAI,cAAc;AAChB,eAAK,cAAc,IAAI,uBAAuB,UAAU,CAAC;AAAA,QAC3D;AAEA,YAAI,cAAc;AAChB,eAAK,cAAc,IAAI,uBAAuB,UAAU,CAAC;AAAA,QAC3D;AAEA,YAAI,YAAY;AACd,cAAI,WAAW,SAAS,YAAY,CAAC,WAAW,QAAQ,QAAQ;AAC9D,yBAAa;AAAA,cACX,OAAO;AAAA,cACP,MAAM;AAAA,YACR;AAAA,UACF;AAEA,cAAI,WAAW,SAAS,SAAS;AAC/B,iBAAK,cAAc,IAAI,WAAW,SAAS,UAAU,CAAC;AAAA,UACxD,OAAO;AACL,iBAAK,cAAc,IAAI,uBAAuB,WAAW,MAAM,UAAU,CAAC;AAAA,UAC5E;AAAA,QACF;AAIA,aAAK,cAAc,IAAI,uBAAuB,KAAK,CAAC;AAEpD,+BAAuB;AAAA,MACzB,SAAS,KAAK;AAEZ,gBAAQ,MAAM,GAAG;AAEjB,cAAM;AAAA,MACR,UAAE;AACA,kBAAU;AACV,mBAAW,QAAQ;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAO,0CAAQ,aAAW;AACxB,QAAM;AAAA,IACJ,cAAcF,aAAY,2BAA2B;AAAA;AAAA;AAAA,IAIrD,kBAAkB;AAAA,IAElB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,oBAAoB;AAAA,EACtB,IAAI,aAAa,OAAO;AAExB,MAAI,CAAC,gBAAgB,CAAC,OAAO,UAAU,gBAAgB,CAAC,OAAO,UAAU,aAAa,eAAe;AACnG,YAAQ;AAAA,MACN;AAAA,IACF;AAEA,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,mBAAmB,OAAM,SAAQ;AACrC,UAAM,EAAE,oBAAoB,QAAQ,2BAA2B,gBAAgB,IAAI,MAAM,iBAAiB;AAC1G,QAAI;AAEJ,QAAI,2BAA2B;AAC7B,YAAM,OAAO,EAAE,UAAU,2BAA2B,MAAM,KAAK,UAAU,OAAO;AAEhF,UAAI,oBAAoB;AACtB,uBAAeG,cAAa,SAAS,IAAI;AACzC,qBAAa,qBAAqB;AAAA,MACpC,OAAO;AACL,uBAAeA,cAAa,SAAS,MAAM,eAAe;AAAA,MAC5D;AAAA,IACF,OAAO;AACL,qBAAe,qBACXA,cAAa,uBAAuB,oBAAoB,MAAM,IAC9DA,cAAa,iBAAiB,iBAAiB,MAAM;AAAA,IAC3D;AAEA,QAAI,6BAA6B;AAC/B,mBAAa,aAAa;AAAA,IAC5B;AAEA,iBAAa,eAAeF,cAAa;AACzC,iBAAa,4BAA4B,QAAQ;AAEjD,WAAO,IAAIG,kBAAiB,cAAc,WAAW;AAAA,EACvD;AAEA,SAAO,8CAA8C;AAAA,IACnD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH;;;AShqBA,IAAO,uBAAQ;;;ACFf,SAAS,eAAAE,cAAa,0BAAAC,yBAAwB,0BAAAC,+BAA8B;AAC5E,SAAS,yBAAyB;;;ACDlC,OAAO,aAAa;;;ACApB,IAAO,+BAAP,MAAqB;AAAA,EACnB,YAAY,cAAc;AACxB,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,QAAQ;AACN,SAAK,gBAAgB,KAAK,aAAa,QAAQ;AAC/C,SAAK,oBAAoB,KAAK,iBAAiB,cAAc,IAAI,YAAY,OAAO,CAAC;AAAA,EACvF;AAAA,EAEA,SAAS;AACP,SAAK,gBAAgB,KAAK,aAAa,OAAO;AAC9C,SAAK,oBAAoB,KAAK,iBAAiB,cAAc,IAAI,YAAY,QAAQ,CAAC;AAAA,EACxF;AAAA,EAEA,MAAM,MAAM,OAAO;AACjB,QAAI;AAEJ,WAAQ,YAAY,MAAM,MAAM,GAAI;AAClC,WAAK,mBAAmB;AAExB,YAAM,UAAU,KAAK,KAAK,YAAY;AAEtC,WAAK,mBAAmB;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,OAAO;AACL,SAAK,oBAAoB,KAAK,iBAAiB,KAAK;AAEpD,QAAI,KAAK,aAAa,UAAU,aAAa;AAM3C,WAAK,aAAa,OAAO;AAAA,IAC3B;AAAA,EACF;AACF;;;ADnCA,IAAO,4BAAP,MAAqB;AAAA,EACnB,YAAY,EAAE,cAAc,SAAS,GAAG;AACtC,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,QAAQ,CAAC;AAEd,SAAK,kBAAkB,QAAQ,MAAM,gBAAgB,IAAI,SAAS,aAAa,CAAC;AAAA,EAClF;AAAA,EAEA,QAAQ;AACN,SAAK,SAAS;AACd,SAAK,YAAY,KAAK,SAAS,MAAM;AAAA,EACvC;AAAA,EAEA,KAAK,WAAW;AACd,SAAK,MAAM,KAAK,SAAS;AACzB,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,SAAS;AACP,SAAK,SAAS;AAEd,QAAI,KAAK,UAAU;AACjB,WAAK,SAAS,OAAO;AAAA,IACvB,OAAO;AACL,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,IAAI,WAAW;AACb,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA,EAEA,MAAM,gBAAgB;AACpB,WAAO,CAAC,KAAK,UAAU,KAAK,MAAM,UAAU,CAAC,KAAK,UAAU;AAC1D,WAAK,WAAW,IAAI,6BAAqB,KAAK,gBAAgB,CAAC;AAE/D,YAAM,KAAK,SAAS,MAAM,KAAK,KAAK;AAEpC,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EAEA,OAAO;AACL,SAAK,MAAM,OAAO,CAAC;AACnB,SAAK,YAAY,KAAK,SAAS,KAAK;AAAA,EACtC;AACF;;;AErDA,SAAS,SAAAC,cAAa;AAEtB,IAAqB,uBAArB,cAAkDA,OAAM;AAAA,EACtD,YAAY,MAAM;AAChB,UAAM,IAAI;AAAA,EACZ;AACF;;;ACJA,SAAS,eAAAC,cAAa,0BAAAC,yBAAwB,0BAAAC,+BAA8B;AAC5E,OAAO,oBAAoB;;;ACH3B,SAAS,cAAc;;;ACIvB,SAAS,mBAAmB,OAAO;AACjC,MAAI,WAAW,KAAK,OAAO,QAAQ,KAAK,GAAG;AAE3C,MAAI,YAAY,GAAG;AACjB,eAAW,MAAM;AAAA,EACnB;AAEA,SAAO,WAAW;AACpB;AAEe,SAAR,UAA2B,EAAE,MAAM,QAAQ,GAAG,OAAO,GAAG,MAAM,OAAO,OAAO,GAAG;AACpF,SAAO,kCAAkC,IAAI;AAAA,qBAC1B,IAAI,WAAW,KAAK;AAAA,sBACnB,mBAAmB,KAAK,CAAC,WAAW,mBAAmB,IAAI,CAAC,aAAa;AAAA,IACzF;AAAA,EACF,CAAC;AAAA,QACG,IAAI;AAAA;AAAA;AAAA;AAIZ;;;ACxBA,IAAM,oBAAoB;AAC1B,IAAM,qBAAqB;AAEZ,SAAR,OAAwB,MAAM;AACnC,SAAO,kBAAkB,KAAK,IAAI,KAAK,mBAAmB,KAAK,IAAI;AACrE;;;AFDA,IAAM,mBAAmB;AACzB,IAAM,wBAAwB;AAC9B,IAAM,gBAAgB;AACtB,IAAM,mBACJ;AAEF,eAAO,wBAAwB;AAAA,EAC7B;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EACP,eAAe;AAAA,EACf;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAQ;AAAA,EACR;AACF,GAAG;AACD,MAAI,CAAC,MAAM;AAET,WAAO,OAAO,gBAAgB;AAAA,EAChC;AAEA,QAAM,EAAE,oBAAoB,QAAQ,yBAAyB,gBAAgB,IAAI,MAAM,iBAAiB;AAExG,MAAK,sBAAsB,mBAAqB,CAAC,sBAAsB,CAAC,iBAAkB;AACxF,UAAM,IAAI,MAAM,+DAA+D;AAAA,EACjF,WAAY,UAAU,2BAA6B,CAAC,UAAU,CAAC,yBAA0B;AACvF,UAAM,IAAI,MAAM,+DAA+D;AAAA,EACjF;AAEA,QAAM,OAAO,OAAO,IAAI,IAAI,OAAO,UAAU,EAAE,MAAM,OAAO,MAAM,MAAM,OAAO,OAAO,CAAC;AAGvF,QAAM,WACJ,4BACC,eACG,GAAG,UAAU,MAAM,CAAC,gCACpB,GAAG,UAAU,MAAM,CAAC;AAC1B,QAAM,SAAS,eAAe,iBAAiB,UAAU,YAAY,CAAC,KAAK;AAC3E,QAAM,MAAM,WAAW,QAAQ,wBAAwB,MAAM;AAE7D,QAAM,MAAM,MAAM,MAAM,KAAK;AAAA,IAC3B,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,4BAA4B;AAAA,MAC5B,GAAI,qBACA;AAAA,QACE,eAAe,UAAU,kBAAkB;AAAA,MAC7C,IACA;AAAA,QACE,6BAA6B;AAAA,MAC/B;AAAA,IACN;AAAA,IACA,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC;AAED,MAAI,CAAC,IAAI,IAAI;AACX,UAAM,IAAI,MAAM,6EAA6E,IAAI,MAAM,EAAE;AAAA,EAC3G;AAEA,SAAO,IAAI,YAAY;AACzB;;;AGlEe,SAAR,eAAgC,QAAQ,MAAM,SAAS;AAC5D,SAAO,iBAAiB,MAAM,OAAO;AAErC,SAAO,MAAM,OAAO,oBAAoB,MAAM,OAAO;AACvD;;;AJKA,SAAS,qBAAqB,cAAc,aAAa;AACvD,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,UAAU,aAAa,gBAAgB,aAAa,SAAS,MAAM;AAGzE,eAAW,OAAO,QAAQ,SAAS,cAAc,QAAQ,OAAO;AAAA,EAClE,CAAC;AACH;AAEA,SAAS,YAAY,cAAc,aAAa,QAAQ;AACtD,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,qBAAqB,IAAI,eAAe;AAC9C,UAAM,cAAc,IAAI,eAAe;AACvC,UAAM,cAAc;AAAA,MAClB;AAAA,MACA;AAAA,MACA,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,UAAU,YAAY,mBAAmB,cAAc;AAAA,IACpF;AAEA,QAAI;AACF,aAAO,SAAS;AAEhB,aAAO,UAAU,YAAY;AAE7B,aAAO,QAAQ,aAAa,WAAW;AACvC,aAAO,MAAM,CAAC;AAEd,cAAQ,KAAK,CAAC,mBAAmB,SAAS,GAAG,YAAY,SAAS,CAAC,CAAC,EAAE,KAAK,OAAO;AAAA,IACpF,SAAS,KAAK;AACZ,aAAO,GAAG;AAAA,IACZ,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF,CAAC;AACH;AAEA,IAAM,2BAAN,cAAuCC,aAAY;AAAA,EACjD,YAAY,MAAM;AAChB,UAAM;AAEN,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,UAAU;AAEf,SAAK,OAAO;AAEZ,SAAK,aAAa;AAClB,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,KAAK,OAAO;AACd,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,IAAI,aAAa;AACf,WAAOC,wBAAuB,MAAM,UAAU;AAAA,EAChD;AAAA,EAEA,IAAI,WAAW,OAAO;AACpB,IAAAC,wBAAuB,MAAM,YAAY,KAAK;AAAA,EAChD;AAAA,EAEA,IAAI,QAAQ;AACV,WAAOD,wBAAuB,MAAM,KAAK;AAAA,EAC3C;AAAA,EAEA,IAAI,MAAM,OAAO;AACf,IAAAC,wBAAuB,MAAM,OAAO,KAAK;AAAA,EAC3C;AAAA,EAEA,IAAI,UAAU;AACZ,WAAOD,wBAAuB,MAAM,OAAO;AAAA,EAC7C;AAAA,EAEA,IAAI,QAAQ,OAAO;AACjB,IAAAC,wBAAuB,MAAM,SAAS,KAAK;AAAA,EAC7C;AAAA,EAEA,IAAI,SAAS;AACX,WAAOD,wBAAuB,MAAM,MAAM;AAAA,EAC5C;AAAA,EAEA,IAAI,OAAO,OAAO;AAChB,IAAAC,wBAAuB,MAAM,QAAQ,KAAK;AAAA,EAC5C;AAAA,EAEA,IAAI,UAAU;AACZ,WAAOD,wBAAuB,MAAM,OAAO;AAAA,EAC7C;AAAA,EAEA,IAAI,QAAQ,OAAO;AACjB,IAAAC,wBAAuB,MAAM,SAAS,KAAK;AAAA,EAC7C;AAAA,EAEA,IAAI,WAAW;AACb,WAAOD,wBAAuB,MAAM,QAAQ;AAAA,EAC9C;AAAA,EAEA,IAAI,SAAS,OAAO;AAClB,IAAAC,wBAAuB,MAAM,UAAU,KAAK;AAAA,EAC9C;AAAA,EAEA,IAAI,UAAU;AACZ,WAAOD,wBAAuB,MAAM,OAAO;AAAA,EAC7C;AAAA,EAEA,IAAI,QAAQ,OAAO;AACjB,IAAAC,wBAAuB,MAAM,SAAS,KAAK;AAAA,EAC7C;AAAA,EAEA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,OAAO;AACf,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,KAAK,OAAO;AACd,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,OAAO;AACf,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,OAAO,OAAO;AAChB,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,QAAQ,EAAE,cAAc,kBAAkB,aAAa,GAAG;AACxD,SAAK,qBAAqB,wBAAgB;AAAA,MACxC;AAAA,MACA;AAAA,MACA,MAAM,KAAK,QAAQ,OAAO,UAAU;AAAA,MACpC;AAAA,MACA,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,OAAO,KAAK,SAAS,KAAK,MAAM;AAAA,MAChC,QAAQ,KAAK;AAAA,IACf,CAAC;AAID,SAAK,mBAAmB,MAAM;AAAA,EAChC;AAAA,EAEA,MAAM,KAAK,cAAc;AACvB,QAAI;AAEF,WAAK,cAAc,IAAI,qBAAqB,OAAO,CAAC;AAGpD,YAAM,SAAS,aAAa,mBAAmB;AAC/C,YAAM,cAAc,MAAM,qBAAqB,cAAc,MAAM,KAAK,kBAAkB;AAE1F,WAAK,iBAAiB;AAEtB,YAAM,YAAY,cAAc,aAAa,MAAM;AAEnD,WAAK,iBAAiB;AACtB,WAAK,cAAc,IAAI,qBAAqB,KAAK,CAAC;AAAA,IACpD,SAAS,OAAO;AAEd,WAAK,cAAc,IAAI,WAAW,SAAS,EAAE,OAAO,oBAAoB,SAAS,MAAM,MAAM,CAAC,CAAC;AAAA,IACjG;AAAA,EACF;AAAA,EAEA,OAAO;AACL,SAAK,kBAAkB,KAAK,eAAe,KAAK;AAAA,EAClD;AACF;AAEA,IAAO,mCAAQ;;;AK9Mf,IAAO,+BAAP,MAAqB;AAAA,EACnB,YAAY,EAAE,QAAQ,MAAM,SAAS,GAAG;AACtC,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,QAAQ;AACb,SAAK,gBAAgB;AACrB,SAAK,QAAQ;AACb,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,IAAI,UAAU;AACZ,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,eAAe;AACjB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AACF;;;AC7BA,eAAe,kBAAkB,EAAE,qBAAqB,cAAc,QAAQ,gBAAgB,GAAG;AAC/F,QAAM,WAAW,uBAAuB,GAAG,MAAM;AAGjD,QAAM,MAAM,MAAM;AAAA,IAChB,WAAW,UAAU,QAAQ,CAAC,oCAAoC,mBAAmB,YAAY,CAAC;AAAA,IAClG;AAAA,MACE,SAAS;AAAA,QACP,QAAQ;AAAA,QACR,6BAA6B;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,IAAI,IAAI;AACX,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AAEA,SAAO,IAAI,KAAK;AAClB;AAEA,eAAO,0BAAwB,EAAE,qBAAqB,cAAc,QAAQ,gBAAgB,GAAG;AAC7F,QAAM,EAAE,OAAO,IAAI,MAAM,kBAAkB,EAAE,qBAAqB,cAAc,QAAQ,gBAAgB,CAAC;AAEzG,SAAO,OACJ;AAAA,IACC,CAAC,EAAE,YAAY,EAAE,QAAQ,OAAO,GAAG,QAAQ,MAAM,MAAM,SAAS,MAC9D,IAAI,6BAAqB,EAAE,QAAQ,MAAM,SAAS,CAAC;AAAA,EACvD,EACC,KAAK,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,MAAO,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,CAAE;AACpE;;;AC9BA,eAAO,YAAmC,EAAE,oBAAoB,QAAQ,yBAAyB,gBAAgB,GAAG;AAElH,QAAM,WAAW,2BAA2B,GAAG,UAAU,MAAM,CAAC;AAChE,QAAM,MAAM,MAAM,MAAM,WAAW,QAAQ,kCAAkC;AAAA,IAC3E,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,GAAI,qBACA;AAAA,QACE,eAAe,UAAU,kBAAkB;AAAA,MAC7C,IACA;AAAA,QACE,6BAA6B;AAAA,MAC/B;AAAA,IACN;AAAA,EACF,CAAC;AAED,MAAI,CAAC,IAAI,IAAI;AACX,UAAM,IAAI,MAAM,wBAAwB;AAAA,EAC1C;AAEA,QAAM,SAAS,MAAM,IAAI,KAAK;AAE9B,SAAO,OACJ,IAAI,CAAC,EAAE,QAAQ,QAAQ,QAAQ,MAAM,MAAM,SAAS,MAAM,IAAI,6BAAqB,EAAE,QAAQ,MAAM,SAAS,CAAC,CAAC,EAC9G,KAAK,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,MAAO,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,CAAE;AACpE;;;AXfA,IAAMC,yBAAwB;AAC9B,IAAM,cAAc,CAAC;AAErB,IAAO,wCAAQ,aAAW;AACxB,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,WAAW;AAAA,MACT,cAAc,OAAO,gBAAgB,OAAO;AAAA,IAC9C;AAAA,IACA;AAAA,IACA,8BAA8BA;AAAA,EAChC,IAAI,aAAa,OAAO;AAExB,MAAI,CAAC,gBAAgB,CAAC,SAAS,cAAc;AAC3C,YAAQ;AAAA,MACN;AAAA,IACF;AAEA,WAAO,CAAC;AAAA,EACV;AAAA,EAEA,MAAM,wBAAwBC,aAAY;AAAA,IACxC,cAAc;AACZ,YAAM;AAEN,WAAK,QAAQ,IAAI,0BAAkB,EAAE,cAAc,SAAS,CAAC;AAE7D,WAAK,aAAa;AAAA,IACpB;AAAA,IAEA,SAAS;AACP,WAAK,MAAM,KAAK;AAAA,IAClB;AAAA,IAEA,YAAY;AACV,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,kBAAkB;AACpB,aAAOC,wBAAuB,MAAM,eAAe;AAAA,IACrD;AAAA,IAEA,IAAI,gBAAgB,OAAO;AACzB,MAAAC,wBAAuB,MAAM,iBAAiB,KAAK;AAAA,IACrD;AAAA,IAEA,QAAQ;AACN,WAAK,MAAM,MAAM;AAAA,IACnB;AAAA,IAEA,SAAS;AACP,WAAK,MAAM,OAAO;AAAA,IACpB;AAAA,IAEA,MAAM,WAAW;AACf,UAAI,EAAE,qBAAqB,mCAA2B;AACpD,cAAM,IAAI,MAAM,mBAAmB;AAAA,MACrC;AAEA,YAAM,EAAE,QAAQ,SAAS,QAAQ,IAAI,OAAe;AACpD,YAAM,cAAc,CAAC,EAAE,OAAO,WAAW,QAAQ,MAAM;AACrD,cAAM,QAAQ,IAAI,MAAM,SAAS;AAEjC,cAAM,QAAQ;AAEd,eAAO,KAAK;AAAA,MACd;AAEA,gBAAU,iBAAiB,OAAO,OAAO;AACzC,gBAAU,iBAAiB,SAAS,WAAW;AAE/C,gBAAU,QAAQ;AAAA,QAChB,cAAc;AAAA,QACd;AAAA,QACA,cAAc;AAAA,MAChB,CAAC;AAED,WAAK,MAAM,KAAK,SAAS;AAEzB,aAAO,QAAQ,QAAQ,MAAM;AAC3B,kBAAU,oBAAoB,OAAO,OAAO;AAC5C,kBAAU,oBAAoB,SAAS,WAAW;AAAA,MACpD,CAAC;AAAA,IACH;AAAA,IAEA,IAAI,WAAW;AACb,aAAO,KAAK,MAAM;AAAA,IACpB;AAAA,IAEA,MAAM,eAAe;AACnB,YAAM,EAAE,qBAAqB,QAAQ,yBAAyB,gBAAgB,IAAI,MAAM,iBAAiB;AAEzG,UAAI,6BAA6B;AAC/B,YAAI,iBAAiB;AACnB,kBAAQ;AAAA,YACN;AAAA,UACF;AAEA,gBAAM,kBAAkB,YAAY;AAClC,kBAAM,SAAS,MAAM,0BAAkB;AAAA,cACrC;AAAA,cACA,cAAc;AAAA,cACd;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAED,iBAAK,YAAY,MAAM;AAAA,UACzB,CAAC;AAAA,QACH;AAAA,MACF,OAAO;AAIL,cAAM,kBAAkB,YAAY;AAClC,gBAAM,SAAS,MAAM,YAAY,MAAM,iBAAiB,CAAC;AAEzD,eAAK,YAAY,MAAM;AAAA,QACzB,CAAC;AAAA,MACH;AAEA,WAAK,cAAc,IAAI,qBAAqB,eAAe,CAAC;AAAA,IAC9D;AAAA,EACF;AAEA,SAAO;AAAA,IACL,iBAAiB,IAAI,gBAAgB;AAAA,IACrC;AAAA,IACA;AAAA,EACF;AACF;;;AY/IA,IAAO,uBAAQ;;;ACFf,IAAM,qBAAqB;AAE3B,eAAO,gCAAwB,EAAE,QAAQ,gBAAgB,GAAG;AAC1D,QAAM,MAAM,MAAM,MAAM,mBAAmB,QAAQ,eAAe,MAAM,GAAG;AAAA,IACzE,SAAS;AAAA,MACP,6BAA6B;AAAA,IAC/B;AAAA,IACA,QAAQ;AAAA,EACV,CAAC;AAED,MAAI,CAAC,IAAI,IAAI;AACX,UAAM,IAAI,MAAM,wDAAwD,IAAI,MAAM,EAAE;AAAA,EACtF;AAEA,SAAO,IAAI,KAAK;AAClB;;;ACPe,SAAR,6BAA8C,UAAU,CAAC,MAAM,MAAM;AAC1E,SAAO;AAAA,IACL,GAAG,qBAAgC,SAAS,GAAG,IAAI;AAAA,IACnD,GAAG,qBAA8B,SAAS,GAAG,IAAI;AAAA,EACnD;AACF;","names":["map","authorizationToken","region","subscriptionKey","AudioConfig","OutputFormat","ResultReason","SpeechConfig","SpeechRecognizer","averageAmplitude","EventTarget","getEventAttributeValue","setEventAttributeValue","Event","EventTarget","getEventAttributeValue","setEventAttributeValue","EventTarget","getEventAttributeValue","setEventAttributeValue","DEFAULT_OUTPUT_FORMAT","EventTarget","getEventAttributeValue","setEventAttributeValue"]}